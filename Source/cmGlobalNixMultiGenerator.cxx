/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
   file LICENSE.rst or https://cmake.org/licensing for details.  */
#include "cmGlobalNixMultiGenerator.h"

#include <algorithm>
#include <cm/memory>
#include <sstream>

#include "cmDocumentationEntry.h"
#include "cmGeneratedFileStream.h"
#include "cmGeneratorTarget.h"
#include "cmLocalNixGenerator.h"
#include "cmMakefile.h"
#include "cmNixTargetGenerator.h"
#include "cmNixWriter.h"
#include "cmSourceFile.h"
#include "cmStateTypes.h"
#include "cmSystemTools.h"
#include "cmake.h"
#include <iostream>
#include "cmOutputConverter.h"
#include "cmLocalGenerator.h"
#include "cmList.h"
#include "cmListFileCache.h"
#include <set>

cmGlobalNixMultiGenerator::cmGlobalNixMultiGenerator(cmake* cm)
  : cmGlobalNixGenerator(cm)
{
  // Multi-config generators don't use CMAKE_BUILD_TYPE
  this->GetCMakeInstance()->GetState()->SetGlobalProperty(
    "CMAKE_BUILD_TYPE", "");
}

std::unique_ptr<cmGlobalGeneratorFactory> cmGlobalNixMultiGenerator::NewFactory()
{
  return std::unique_ptr<cmGlobalGeneratorFactory>(
    new cmGlobalGeneratorSimpleFactory<cmGlobalNixMultiGenerator>());
}

std::vector<std::string> cmGlobalNixMultiGenerator::GetConfigurationTypes() const
{
  std::vector<std::string> configs;
  
  // Get CMAKE_CONFIGURATION_TYPES property
  cmValue configTypes = 
    this->GetCMakeInstance()->GetState()->GetGlobalProperty("CMAKE_CONFIGURATION_TYPES");
  if (configTypes && !configTypes->empty()) {
    cmExpandList(*configTypes, configs);
  }
  
  // Default configurations if none specified
  if (configs.empty()) {
    configs.emplace_back("Debug");
    configs.emplace_back("Release");
    configs.emplace_back("RelWithDebInfo");
    configs.emplace_back("MinSizeRel");
  }
  
  return configs;
}

std::string cmGlobalNixMultiGenerator::GetDefaultConfiguration() const
{
  // Check for CMAKE_DEFAULT_BUILD_TYPE first
  cmValue defaultBuildType = 
    this->GetCMakeInstance()->GetState()->GetGlobalProperty("CMAKE_DEFAULT_BUILD_TYPE");
  if (defaultBuildType && !defaultBuildType->empty()) {
    return *defaultBuildType;
  }
  
  // Fall back to first configuration
  std::vector<std::string> configs = this->GetConfigurationTypes();
  return configs.empty() ? "Release" : configs[0];
}

void cmGlobalNixMultiGenerator::WriteNixFile()
{
  std::string nixFilePath = this->GetCMakeInstance()->GetHomeDirectory();
  nixFilePath += "/default.nix";
  
  cmGeneratedFileStream nixFileStream(nixFilePath);
  
  // Use NixWriter for cleaner code generation
  cmNixWriter writer(nixFileStream);
  
  // Write the Nix expression header
  writer.WriteComment("Generated by CMake Nix Multi-Config Generator");
  writer.WriteLine("with import <nixpkgs> {};");
  writer.WriteLine("with pkgs;");
  writer.WriteLine();
  writer.StartLetBinding();
  
  // Write helper functions from parent class
  this->WriteNixHelperFunctions(writer);
  
  // Write per-translation-unit derivations for all configurations
  this->WritePerTranslationUnitDerivations(nixFileStream);
  
  // Write linking derivations for all configurations
  this->WriteLinkingDerivations(nixFileStream);
  
  // Get all configurations
  std::vector<std::string> configs = this->GetConfigurationTypes();
  
  // Write the main attribute set with all targets and configurations
  nixFileStream << "\nin\n{\n";
  
  // Get all targets
  for (auto const& lg : this->LocalGenerators) {
    auto const& targets = lg->GetGeneratorTargets();
    for (auto const& target : targets) {
      if (target->GetType() == cmStateEnums::EXECUTABLE ||
          target->GetType() == cmStateEnums::STATIC_LIBRARY ||
          target->GetType() == cmStateEnums::SHARED_LIBRARY) {
        
        std::string targetName = target->GetName();
        
        // Add entry for each configuration
        for (const std::string& config : configs) {
          std::string attrName = targetName + "_" + cmSystemTools::LowerCase(config);
          std::string derivName = this->GetDerivationNameForConfig(targetName, "", config);
          nixFileStream << "  \"" << attrName << "\" = " << derivName << ";\n";
        }
        
        // Add a default entry pointing to the default configuration
        std::string defaultConfig = this->GetDefaultConfiguration();
        std::string defaultDerivName = this->GetDerivationNameForConfig(targetName, "", defaultConfig);
        nixFileStream << "  \"" << targetName << "\" = " << defaultDerivName << ";\n";
      }
    }
  }
  
  nixFileStream << "}\n";
}

void cmGlobalNixMultiGenerator::WritePerTranslationUnitDerivations(cmGeneratedFileStream& nixFileStream)
{
  nixFileStream << "  # Per-translation-unit derivations for all configurations\n";
  
  std::vector<std::string> configs = this->GetConfigurationTypes();
  
  for (auto const& lg : this->LocalGenerators) {
    auto const& targets = lg->GetGeneratorTargets();
    for (auto const& target : targets) {
      if (target->GetType() == cmStateEnums::EXECUTABLE ||
          target->GetType() == cmStateEnums::STATIC_LIBRARY ||
          target->GetType() == cmStateEnums::SHARED_LIBRARY ||
          target->GetType() == cmStateEnums::OBJECT_LIBRARY) {
        
        // Get source files for this target
        std::vector<cmSourceFile*> sources;
        target->GetSourceFiles(sources, "");
        
        for (cmSourceFile* source : sources) {
          std::string const& lang = source->GetLanguage();
          if (lang == "C" || lang == "CXX" || lang == "Fortran" || lang == "CUDA") {
            // Write derivation for each configuration
            for (const std::string& config : configs) {
              this->WriteObjectDerivationForConfig(nixFileStream, target.get(), source, config);
            }
          }
        }
      }
    }
  }
}

void cmGlobalNixMultiGenerator::WriteLinkingDerivations(cmGeneratedFileStream& nixFileStream)
{
  nixFileStream << "\n  # Linking derivations for all configurations\n";
  
  std::vector<std::string> configs = this->GetConfigurationTypes();
  
  for (auto const& lg : this->LocalGenerators) {
    auto const& targets = lg->GetGeneratorTargets();
    for (auto const& target : targets) {
      if (target->GetType() == cmStateEnums::EXECUTABLE ||
          target->GetType() == cmStateEnums::STATIC_LIBRARY ||
          target->GetType() == cmStateEnums::SHARED_LIBRARY) {
        // Write linking derivation for each configuration
        for (const std::string& config : configs) {
          this->WriteLinkDerivationForConfig(nixFileStream, target.get(), config);
        }
      }
    }
  }
}

void cmGlobalNixMultiGenerator::WriteObjectDerivationForConfig(
  cmGeneratedFileStream& nixFileStream, 
  cmGeneratorTarget* target, 
  cmSourceFile* source,
  const std::string& config)
{
  std::string sourceFile = source->GetFullPath();
  std::string derivName = this->GetDerivationNameForConfig(target->GetName(), sourceFile, config);
  
  // Create target generator to get dependencies
  auto targetGen = cmNixTargetGenerator::New(target);
  std::vector<std::string> dependencies = targetGen->GetSourceDependencies(source);
  
  // IMPORTANT: We don't call parent's WriteObjectDerivation because it would use the wrong name
  // Instead, we write it directly here with config-specific naming
  
  std::string objectName = targetGen->GetObjectFileName(source);
  std::string lang = source->GetLanguage();
  
  // Store the object derivation info with config-specific name
  this->AddObjectDerivation(target->GetName(), derivName, sourceFile, 
                           objectName, lang, dependencies);
  
  // Get the local generator for this target
  cmLocalGenerator* lg = target->GetLocalGenerator();
  
  // Temporarily set CMAKE_BUILD_TYPE for proper flag generation
  std::string oldBuildType = target->Target->GetMakefile()->GetSafeDefinition("CMAKE_BUILD_TYPE");
  target->Target->GetMakefile()->SetProperty("CMAKE_BUILD_TYPE", config.c_str());
  
  // Get configuration-specific compile flags
  std::vector<BT<std::string>> compileFlagsVec = lg->GetTargetCompileFlags(target, config, lang, "");
  std::ostringstream compileFlagsStream;
  bool firstFlag = true;
  for (const auto& flag : compileFlagsVec) {
    if (!firstFlag) compileFlagsStream << " ";
    firstFlag = false;
    compileFlagsStream << flag.Value;
  }
  std::string compileFlags = compileFlagsStream.str();
  
  // Get configuration-specific preprocessor definitions
  std::set<std::string> defines;
  lg->GetTargetDefines(target, config, lang, defines);
  std::ostringstream defineFlagsStream;
  bool firstDefine = true;
  for (const std::string& define : defines) {
    if (!firstDefine) defineFlagsStream << " ";
    firstDefine = false;
    // Shell escape the define - need to handle quotes properly
    defineFlagsStream << "-D" << lg->ConvertToOutputFormat(define, cmOutputConverter::SHELL);
  }
  std::string defineFlags = defineFlagsStream.str();
  
  // Get include directories
  std::vector<std::string> includes;
  lg->GetIncludeDirectories(includes, target, lang, config);
  std::ostringstream includeFlagsStream;
  bool firstInclude = true;
  for (const std::string& inc : includes) {
    if (!firstInclude) includeFlagsStream << " ";
    firstInclude = false;
    includeFlagsStream << "-I" << lg->ConvertToOutputFormat(inc, cmOutputConverter::SHELL);
  }
  std::string includeFlags = includeFlagsStream.str();
  
  // Get relative source path
  std::string relSourcePath = lg->MaybeRelativeToTopBinDir(sourceFile);
  
  // Combine all flags
  std::string allFlags;
  if (!compileFlags.empty()) {
    allFlags += compileFlags;
  }
  if (!defineFlags.empty()) {
    if (!allFlags.empty()) allFlags += " ";
    allFlags += defineFlags;
  }
  if (!includeFlags.empty()) {
    if (!allFlags.empty()) allFlags += " ";
    allFlags += includeFlags;
  }
  
  // Write the derivation using cmakeNixCC helper
  nixFileStream << "  " << derivName << " = cmakeNixCC {\n";
  nixFileStream << "    name = \"" << objectName << "\";\n";
  
  // Handle source specification
  if (this->UseExplicitSources()) {
    // Write explicit source derivation using already computed dependencies
    std::string projectSourceRelPath = ""; // Multi-generator always uses project root
    this->WriteExplicitSourceDerivation(nixFileStream, source->GetFullPath(), dependencies, projectSourceRelPath);
  } else {
    nixFileStream << "    src = ./.;\n";
  }
  
  // Use the correct compiler package based on language
  std::string compilerPkg = this->GetCompilerPackage(lang);
  nixFileStream << "    compiler = " << compilerPkg << ";\n";
  nixFileStream << "    source = \"" << relSourcePath << "\";\n";
  
  if (!allFlags.empty()) {
    nixFileStream << "    flags = \"" << allFlags << "\";\n";
  }
  
  // Add header dependencies if any
  if (!dependencies.empty()) {
    nixFileStream << "    propagatedInputs = [\n";
    for (const std::string& header : dependencies) {
      nixFileStream << "      ./" << header << "\n";
    }
    nixFileStream << "    ];\n";
  }
  
  nixFileStream << "  }; # Configuration: " << config << "\n";
  
  // Restore original CMAKE_BUILD_TYPE
  target->Target->GetMakefile()->SetProperty("CMAKE_BUILD_TYPE", oldBuildType.c_str());
}

void cmGlobalNixMultiGenerator::WriteLinkDerivationForConfig(
  cmGeneratedFileStream& nixFileStream,
  cmGeneratorTarget* target,
  const std::string& config)
{
  std::string derivName = this->GetDerivationNameForConfig(target->GetName(), "", config);
  
  // We can't use parent's WriteLinkDerivation because it would generate the wrong name
  // So we need to implement it here with config-specific naming
  
  std::string outputName;
  cmStateEnums::TargetType targetType = target->GetType();
  
  if (targetType == cmStateEnums::EXECUTABLE) {
    outputName = target->GetName();
  } else if (targetType == cmStateEnums::STATIC_LIBRARY) {
    outputName = this->GetLibraryPrefix() + target->GetName() + this->GetStaticLibraryExtension();
  } else if (targetType == cmStateEnums::SHARED_LIBRARY) {
    outputName = this->GetLibraryPrefix() + target->GetName() + this->GetSharedLibraryExtension();
  }
  
  // Temporarily set CMAKE_BUILD_TYPE for proper flag/object generation
  std::string oldBuildType = target->Target->GetMakefile()->GetSafeDefinition("CMAKE_BUILD_TYPE");
  target->Target->GetMakefile()->SetProperty("CMAKE_BUILD_TYPE", config.c_str());
  
  // Get object dependencies with config suffix
  std::vector<cmSourceFile*> sources;
  target->GetSourceFiles(sources, config);
  
  std::vector<std::string> objectDeps;
  for (cmSourceFile* source : sources) {
    std::string const& lang = source->GetLanguage();
    if (lang == "C" || lang == "CXX" || lang == "Fortran" || lang == "CUDA") {
      std::string objDerivName = this->GetDerivationNameForConfig(
        target->GetName(), source->GetFullPath(), config);
      objectDeps.push_back(objDerivName);
    }
  }
  
  // Determine primary language
  std::string primaryLang = "C";
  for (cmSourceFile* source : sources) {
    if (source->GetLanguage() == "CXX") {
      primaryLang = "CXX";
      break;
    }
  }
  
  // Get link flags
  cmLocalGenerator* lg = target->GetLocalGenerator();
  std::ostringstream linkFlagsStream;
  bool firstLinkFlag = true;
  
  // Get link options
  std::vector<BT<std::string>> linkOpts = target->GetLinkOptions(config, primaryLang);
  for (const auto& opt : linkOpts) {
    if (!firstLinkFlag) linkFlagsStream << " ";
    firstLinkFlag = false;
    linkFlagsStream << opt.Value;
  }
  
  // Get link directories
  std::vector<BT<std::string>> linkDirs = target->GetLinkDirectories(config, primaryLang);
  for (const auto& dir : linkDirs) {
    if (!firstLinkFlag) linkFlagsStream << " ";
    firstLinkFlag = false;
    linkFlagsStream << "-L" << lg->ConvertToOutputFormat(dir.Value, cmOutputConverter::SHELL);
  }
  
  // Get runtime path flags if needed
  if (targetType == cmStateEnums::SHARED_LIBRARY || targetType == cmStateEnums::EXECUTABLE) {
    std::string rpath;
    if (target->GetInstallRPATH(config, rpath) && !rpath.empty()) {
      if (!firstLinkFlag) linkFlagsStream << " ";
      firstLinkFlag = false;
      linkFlagsStream << "-Wl,-rpath," << rpath;
    }
  }
  
  std::string linkFlags = linkFlagsStream.str();
  
  // Get library dependencies
  auto targetGen = cmNixTargetGenerator::New(target);
  std::vector<std::string> libraryDeps = targetGen->GetTargetLibraryDependencies(config);
  std::vector<std::string> libraries;
  for (const std::string& lib : libraryDeps) {
    if (!lib.empty()) {
      if (lib.find("__NIXPKG__") == 0) {
        std::string nixPkg = lib.substr(9);
        if (!nixPkg.empty()) {
          libraries.push_back(nixPkg);
        }
      } else {
        libraries.push_back("(" + lib + ")");
      }
    }
  }
  
  // Map target type to cmakeNixLD type parameter
  std::string linkType;
  if (targetType == cmStateEnums::EXECUTABLE) {
    linkType = "executable";
  } else if (targetType == cmStateEnums::STATIC_LIBRARY) {
    linkType = "static";
  } else if (targetType == cmStateEnums::SHARED_LIBRARY) {
    linkType = "shared";
  } else if (targetType == cmStateEnums::MODULE_LIBRARY) {
    linkType = "module";
  }
  
  // Write the derivation using cmakeNixLD helper
  nixFileStream << "  " << derivName << " = cmakeNixLD {\n";
  nixFileStream << "    name = \"" << outputName << "\";\n";
  nixFileStream << "    type = \"" << linkType << "\";\n";
  nixFileStream << "    compiler = " << this->GetCompilerPackage(primaryLang) << ";\n";
  
  // Object dependencies
  if (!objectDeps.empty()) {
    nixFileStream << "    objects = [\n";
    for (const std::string& objDep : objectDeps) {
      nixFileStream << "      " << objDep << "\n";
    }
    nixFileStream << "    ];\n";
  }
  
  // Link flags
  if (!linkFlags.empty()) {
    nixFileStream << "    flags = \"" << linkFlags << "\";\n";
  }
  
  // Libraries
  if (!libraries.empty()) {
    nixFileStream << "    libraries = [\n";
    for (const std::string& lib : libraries) {
      nixFileStream << "      " << lib << "\n";
    }
    nixFileStream << "    ];\n";
  }
  
  // Add buildInputs if there are library dependencies
  if (!libraries.empty()) {
    nixFileStream << "    buildInputs = [\n";
    for (const std::string& lib : libraries) {
      nixFileStream << "      " << lib << "\n";
    }
    nixFileStream << "    ];\n";
  }
  
  nixFileStream << "  }; # Configuration: " << config << "\n";
  
  // Restore original CMAKE_BUILD_TYPE
  target->Target->GetMakefile()->SetProperty("CMAKE_BUILD_TYPE", oldBuildType.c_str());
}

std::string cmGlobalNixMultiGenerator::GetDerivationNameForConfig(
  const std::string& targetName,
  const std::string& sourceFile,
  const std::string& config) const
{
  std::string configLower = cmSystemTools::LowerCase(config);
  
  if (sourceFile.empty()) {
    return "link_" + targetName + "_" + configLower;
  } else {
    // Get base derivation name from parent class
    std::string baseName = this->GetDerivationName(targetName, sourceFile);
    // Replace "link_" prefix or append config suffix
    if (baseName.find("link_") == 0) {
      return baseName + "_" + configLower;
    } else {
      // For object files, insert config before the "_o" suffix
      size_t pos = baseName.rfind("_o");
      if (pos != std::string::npos) {
        return baseName.substr(0, pos) + "_" + configLower + "_o";
      } else {
        return baseName + "_" + configLower;
      }
    }
  }
}