/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
   file LICENSE.rst or https://cmake.org/licensing for details.  */
#include "cmGlobalNixGenerator.h"

#include <cm/memory>
#include <iostream>
#include <sstream>
#include <algorithm>

#include "cmGeneratedFileStream.h"
#include "cmGeneratorTarget.h"
#include "cmLocalNixGenerator.h"
#include "cmMakefile.h"
#include "cmSourceFile.h"
#include "cmSystemTools.h"
#include "cmake.h"
#include "cmNixTargetGenerator.h"
#include "cmListFileCache.h"
#include "cmValue.h"
#include "cmState.h"

cmGlobalNixGenerator::cmGlobalNixGenerator(cmake* cm)
  : cmGlobalCommonGenerator(cm)
{
  // Set the make program file
  this->FindMakeProgramFile = "CMakeNixFindMake.cmake";
}

std::unique_ptr<cmLocalGenerator> cmGlobalNixGenerator::CreateLocalGenerator(
  cmMakefile* mf)
{
  return std::unique_ptr<cmLocalGenerator>(
    cm::make_unique<cmLocalNixGenerator>(this, mf));
}

cmDocumentationEntry cmGlobalNixGenerator::GetDocumentation()
{
  return { cmGlobalNixGenerator::GetActualName(),
           "Generates Nix expressions for building C/C++ projects with "
           "fine-grained derivations for maximal parallelism and caching." };
}

void cmGlobalNixGenerator::Generate()
{
  // First call the parent Generate to set up targets
  this->cmGlobalGenerator::Generate();
  
  // Generate our Nix output
  this->WriteNixFile();
}

std::vector<cmGlobalGenerator::GeneratedMakeCommand>
cmGlobalNixGenerator::GenerateBuildCommand(
  std::string const& makeProgram, std::string const& /*projectName*/,
  std::string const& /*projectDir*/,
  std::vector<std::string> const& targetNames, std::string const& /*config*/,
  int /*jobs*/, bool /*verbose*/, cmBuildOptions const& /*buildOptions*/,
  std::vector<std::string> const& /*makeOptions*/)
{
  GeneratedMakeCommand makeCommand;
  
  // For Nix generator, we use nix-build as the build program
  makeCommand.Add(this->SelectMakeProgram(makeProgram, "nix-build"));
  
  // Add default.nix file
  makeCommand.Add("default.nix");
  
  // Add target names as attribute paths  
  for (auto const& tname : targetNames) {
    if (!tname.empty()) {
      makeCommand.Add("-A", tname);
    }
  }
  
  return { std::move(makeCommand) };
}

void cmGlobalNixGenerator::WriteNixFile()
{
  std::string nixFile = this->GetCMakeInstance()->GetHomeOutputDirectory();
  nixFile += "/default.nix";
  
  cmGeneratedFileStream nixFileStream(nixFile);
  nixFileStream.SetCopyIfDifferent(true);
  
  if (!nixFileStream) {
    return;
  }

  // Write Nix file header
  nixFileStream << "# Generated by CMake Nix Generator\n"
                << "with import <nixpkgs> {};\n\n"
                << "let\n";

  // Write per-translation-unit derivations
  this->WritePerTranslationUnitDerivations(nixFileStream);
  
  // Write linking derivations
  this->WriteLinkingDerivations(nixFileStream);
  
  nixFileStream << "in\n{\n";
  
  // Write final target outputs
  for (auto const& lg : this->LocalGenerators) {
    auto const& targets = lg->GetGeneratorTargets();
    for (auto const& target : targets) {
      if (target->GetType() == cmStateEnums::EXECUTABLE ||
          target->GetType() == cmStateEnums::STATIC_LIBRARY ||
          target->GetType() == cmStateEnums::SHARED_LIBRARY) {
        nixFileStream << "  \"" << target->GetName() << "\" = "
                      << this->GetDerivationName(target->GetName()) << ";\n";
      }
    }
  }
  
  nixFileStream << "}\n";
}

void cmGlobalNixGenerator::WritePerTranslationUnitDerivations(
  cmGeneratedFileStream& nixFileStream)
{
  nixFileStream << "  # Per-translation-unit derivations\n";
  
  for (auto const& lg : this->LocalGenerators) {
    auto const& targets = lg->GetGeneratorTargets();
    for (auto const& target : targets) {
      if (target->GetType() == cmStateEnums::EXECUTABLE ||
          target->GetType() == cmStateEnums::STATIC_LIBRARY ||
          target->GetType() == cmStateEnums::SHARED_LIBRARY) {
        
        // Get source files for this target
        std::vector<cmSourceFile*> sources;
        target->GetSourceFiles(sources, "");
        
        for (cmSourceFile* source : sources) {
          std::string const& lang = source->GetLanguage();
          if (lang == "C" || lang == "CXX") {
            this->WriteObjectDerivation(nixFileStream, target.get(), source);
          }
        }
      }
    }
  }
}

void cmGlobalNixGenerator::WriteLinkingDerivations(
  cmGeneratedFileStream& nixFileStream)
{
  nixFileStream << "\n  # Linking derivations\n";
  
  for (auto const& lg : this->LocalGenerators) {
    auto const& targets = lg->GetGeneratorTargets();
    for (auto const& target : targets) {
      if (target->GetType() == cmStateEnums::EXECUTABLE ||
          target->GetType() == cmStateEnums::STATIC_LIBRARY ||
          target->GetType() == cmStateEnums::SHARED_LIBRARY) {
        this->WriteLinkDerivation(nixFileStream, target.get());
      }
    }
  }
}

std::string cmGlobalNixGenerator::GetDerivationName(
  std::string const& targetName, std::string const& sourceFile) const
{
  if (sourceFile.empty()) {
    return "link_" + targetName;
  }
  
  // Use just the filename, not the full path
  std::string filename = cmSystemTools::GetFilenameName(sourceFile);
  
  // Convert filename to valid Nix identifier
  std::string name = filename;
  std::replace(name.begin(), name.end(), '.', '_');
  return targetName + "_" + name + "_o";
}

void cmGlobalNixGenerator::WriteObjectDerivation(
  cmGeneratedFileStream& nixFileStream, cmGeneratorTarget* target, 
  cmSourceFile* source)
{
  std::string sourceFile = source->GetFullPath();
  std::string derivName = this->GetDerivationName(target->GetName(), sourceFile);
  std::string objectName = cmSystemTools::GetFilenameWithoutLastExtension(
    cmSystemTools::GetFilenameName(sourceFile)) + ".o";
  std::string lang = source->GetLanguage();
  
  // Get the configuration (Debug, Release, etc.)
  std::string config = target->Target->GetMakefile()->GetSafeDefinition("CMAKE_BUILD_TYPE");
  if (config.empty()) {
    config = "Release"; // Default configuration
  }
  
  // Get the local generator for this target
  cmLocalGenerator* lg = target->GetLocalGenerator();
  
  // Get configuration-specific compile flags
  std::string compileFlags;
  lg->GetTargetCompileFlags(target, config, lang, compileFlags);
  
  // Get configuration-specific preprocessor definitions
  std::set<std::string> defines;
  lg->GetTargetDefines(target, config, lang, defines);
  std::string defineFlags;
  for (const std::string& define : defines) {
    if (!defineFlags.empty()) defineFlags += " ";
    defineFlags += "-D" + define;
  }
  
  // Get include directories from target with proper configuration
  std::vector<BT<std::string>> includesBT = target->GetIncludeDirectories(lang, config);
  std::string includeFlags;
  for (const auto& inc : includesBT) {
    if (!includeFlags.empty()) includeFlags += " ";
    // Convert absolute include paths to relative for Nix build environment
    std::string relativeInclude = cmSystemTools::RelativePath(
      this->GetCMakeInstance()->GetHomeOutputDirectory(), inc.Value);
    includeFlags += "-I" + (!relativeInclude.empty() ? relativeInclude : inc.Value);
  }
  
  nixFileStream << "  " << derivName << " = stdenv.mkDerivation {\n";
  nixFileStream << "    name = \"" << objectName << "\";\n";
  nixFileStream << "    src = ./.;\n";
  
  // Get external library dependencies for compilation (headers)
  auto targetGen = cmNixTargetGenerator::New(target);
  std::vector<std::string> libraryDeps = targetGen->GetTargetLibraryDependencies(config);
  
  // Build buildInputs list including external libraries for headers
  std::string compilerPkg = this->GetCompilerPackage(lang);
  nixFileStream << "    buildInputs = [ " << compilerPkg;
  for (const std::string& lib : libraryDeps) {
    if (!lib.empty()) {
      nixFileStream << " (import " << lib << " { inherit pkgs; })";
    }
  }
  nixFileStream << " ];\n";
  
  nixFileStream << "    dontFixup = true;\n";
  
  // Add header dependencies - get them from target generator  
  std::vector<std::string> headers = targetGen->GetSourceDependencies(source);
  
  if (!headers.empty()) {
    nixFileStream << "    # Header dependencies\n";
    nixFileStream << "    propagatedInputs = [\n";
    for (const std::string& header : headers) {
      nixFileStream << "      ./" << header << "\n";
    }
    nixFileStream << "    ];\n";
  }
  
  nixFileStream << "    # Configuration: " << config << "\n";
  nixFileStream << "    buildPhase = ''\n";
  std::string relativePath = cmSystemTools::RelativePath(
    this->GetCMakeInstance()->GetHomeOutputDirectory(), sourceFile);
  
  // Combine all flags: compile flags + defines + includes
  std::string allFlags;
  if (!compileFlags.empty()) allFlags += compileFlags + " ";
  if (!defineFlags.empty()) allFlags += defineFlags + " ";
  if (!includeFlags.empty()) allFlags += includeFlags;
  
  std::string compilerCmd = this->GetCompilerCommand(lang);
  nixFileStream << "      " << compilerCmd << " -c " << allFlags << " \"" << relativePath 
    << "\" -o \"$out\"\n";
  nixFileStream << "    '';\n";
  nixFileStream << "    installPhase = \"true\"; # No install needed for objects\n";
  nixFileStream << "  };\n\n";
}

void cmGlobalNixGenerator::WriteLinkDerivation(
  cmGeneratedFileStream& nixFileStream, cmGeneratorTarget* target)
{
  std::string derivName = this->GetDerivationName(target->GetName());
  std::string targetName = target->GetName();
  
  nixFileStream << "  " << derivName << " = stdenv.mkDerivation {\n";
  nixFileStream << "    name = \"" << targetName << "\";\n";
  
  // Get external library dependencies using target generator
  auto targetGen = cmNixTargetGenerator::New(target);
  std::string config = target->Target->GetMakefile()->GetSafeDefinition("CMAKE_BUILD_TYPE");
  if (config.empty()) {
    config = "Release";
  }
  std::vector<std::string> libraryDeps = targetGen->GetTargetLibraryDependencies(config);
  
  // Build buildInputs list including external libraries
  // Determine the primary language for linking
  std::string primaryLang = "C";
  std::vector<cmSourceFile*> sources;
  target->GetSourceFiles(sources, "");
  for (cmSourceFile* source : sources) {
    if (source->GetLanguage() == "CXX") {
      primaryLang = "CXX";
      break;  // C++ takes precedence
    }
  }
  
  std::string compilerPkg = this->GetCompilerPackage(primaryLang);
  nixFileStream << "    buildInputs = [ " << compilerPkg;
  for (const std::string& lib : libraryDeps) {
    if (!lib.empty()) {
      nixFileStream << " (import " << lib << " { inherit pkgs; })";
    }
  }
  nixFileStream << " ];\n";
  
  nixFileStream << "    dontUnpack = true;\n";  // No source to unpack
  
  // Collect object file dependencies (reuse sources from above)
  
  nixFileStream << "    objects = [\n";
  for (cmSourceFile* source : sources) {
    std::string const& lang = source->GetLanguage();
    if (lang == "C" || lang == "CXX") {
      std::string objDerivName = this->GetDerivationName(
        target->GetName(), source->GetFullPath());
      nixFileStream << "      " << objDerivName << "\n";
    }
  }
  nixFileStream << "    ];\n";
  
  // Get library link flags for build phase
  std::string linkFlags;
  if (!libraryDeps.empty()) {
    // Add library flags based on actual library names
    auto linkImpl = target->GetLinkImplementation(config, cmGeneratorTarget::UseTo::Compile);
    if (linkImpl) {
      for (const cmLinkItem& item : linkImpl->Libraries) {
        if (!item.Target) { // External library
          std::string libName = item.AsStr();
          linkFlags += " -l" + libName;
        }
      }
    }
  }
  
  std::string linkCompilerCmd = this->GetCompilerCommand(primaryLang);
  nixFileStream << "    buildPhase = ''\n";
  if (target->GetType() == cmStateEnums::EXECUTABLE) {
    nixFileStream << "      " << linkCompilerCmd << " $objects" << linkFlags << " -o \"$out\"\n";
  } else if (target->GetType() == cmStateEnums::STATIC_LIBRARY) {
    nixFileStream << "      ar rcs \"$out\" $objects\n";
  } else if (target->GetType() == cmStateEnums::SHARED_LIBRARY) {
    nixFileStream << "      " << linkCompilerCmd << " -shared $objects" << linkFlags << " -o \"$out\"\n";
  }
  nixFileStream << "    '';\n";
  nixFileStream << "    installPhase = \"true\"; # No install needed\n";
  nixFileStream << "  };\n\n";
}

std::vector<std::string> cmGlobalNixGenerator::GetSourceDependencies(
  std::string const& /*sourceFile*/) const
{
  // TODO: Implement header dependency tracking
  // This will use CMake's existing dependency analysis
  return {};
}

std::string cmGlobalNixGenerator::GetCompilerPackage(const std::string& lang) const
{
  cmake* cm = this->GetCMakeInstance();
  std::string compilerIdVar = "CMAKE_" + lang + "_COMPILER_ID";
  
  cmValue compilerId = cm->GetState()->GetGlobalProperty(compilerIdVar);
  if (!compilerId) {
    // Try to get from cache
    compilerId = cm->GetCacheDefinition(compilerIdVar);
  }
  
  if (compilerId) {
    std::string id = *compilerId;
    if (id == "GNU") {
      return "gcc";
    } else if (id == "Clang" || id == "AppleClang") {
      return "clang";
    } else if (id == "MSVC") {
      // For future Windows support
      return "msvc";
    }
  }
  
  // Default fallback - in Nix context, gcc is usually available
  return "gcc";
}

std::string cmGlobalNixGenerator::GetCompilerCommand(const std::string& lang) const
{
  // In Nix, we use the compiler from the Nix package
  // The actual command depends on the package and language
  std::string compilerPkg = this->GetCompilerPackage(lang);
  
  if (compilerPkg == "gcc") {
    return (lang == "CXX") ? "g++" : "gcc";
  } else if (compilerPkg == "clang") {
    return (lang == "CXX") ? "clang++" : "clang";
  }
  
  // Default fallback
  return (lang == "CXX") ? "g++" : "gcc";
} 