/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
   file LICENSE.rst or https://cmake.org/licensing for details.  */
#include "cmGlobalNixGenerator.h"

#include <cm/memory>
#include <iostream>
#include <sstream>
#include <algorithm>

#include "cmGeneratedFileStream.h"
#include "cmGeneratorTarget.h"
#include "cmLocalNixGenerator.h"
#include "cmMakefile.h"
#include "cmSourceFile.h"
#include "cmSystemTools.h"
#include "cmake.h"

cmGlobalNixGenerator::cmGlobalNixGenerator(cmake* cm)
  : cmGlobalCommonGenerator(cm)
{
  // Set the make program file
  this->FindMakeProgramFile = "CMakeNixFindMake.cmake";
}

std::unique_ptr<cmLocalGenerator> cmGlobalNixGenerator::CreateLocalGenerator(
  cmMakefile* mf)
{
  return std::unique_ptr<cmLocalGenerator>(
    cm::make_unique<cmLocalNixGenerator>(this, mf));
}

cmDocumentationEntry cmGlobalNixGenerator::GetDocumentation()
{
  return { cmGlobalNixGenerator::GetActualName(),
           "Generates Nix expressions for building C/C++ projects with "
           "fine-grained derivations for maximal parallelism and caching." };
}

void cmGlobalNixGenerator::Generate()
{
  // First call the parent Generate to set up targets
  this->cmGlobalGenerator::Generate();
  
  // Generate our Nix output
  this->WriteNixFile();
}

std::vector<cmGlobalGenerator::GeneratedMakeCommand>
cmGlobalNixGenerator::GenerateBuildCommand(
  std::string const& makeProgram, std::string const& /*projectName*/,
  std::string const& /*projectDir*/,
  std::vector<std::string> const& targetNames, std::string const& /*config*/,
  int /*jobs*/, bool /*verbose*/, cmBuildOptions const& /*buildOptions*/,
  std::vector<std::string> const& /*makeOptions*/)
{
  GeneratedMakeCommand makeCommand;
  
  // For Nix generator, we use nix-build as the build program
  makeCommand.Add(this->SelectMakeProgram(makeProgram, "nix-build"));
  
  // Add default.nix file
  makeCommand.Add("default.nix");
  
  // Add target names as attribute paths  
  for (auto const& tname : targetNames) {
    if (!tname.empty()) {
      makeCommand.Add("-A", tname);
    }
  }
  
  return { std::move(makeCommand) };
}

void cmGlobalNixGenerator::WriteNixFile()
{
  std::string nixFile = this->GetCMakeInstance()->GetHomeOutputDirectory();
  nixFile += "/default.nix";
  
  cmGeneratedFileStream nixFileStream(nixFile);
  nixFileStream.SetCopyIfDifferent(true);
  
  if (!nixFileStream) {
    return;
  }

  // Write Nix file header
  nixFileStream << "# Generated by CMake Nix Generator\n"
                << "{ stdenv, gcc }:\n\n"
                << "let\n"
                << "  # Per-translation-unit derivations\n";

  this->WritePerTranslationUnitDerivations();
  
  nixFileStream << "\n  # Linking derivations\n";
  this->WriteLinkingDerivations();
  
  nixFileStream << "\nin\n{\n";
  
  // Write final target outputs
  for (auto const& lg : this->LocalGenerators) {
    auto const& targets = lg->GetGeneratorTargets();
    for (auto const& target : targets) {
      if (target->GetType() == cmStateEnums::EXECUTABLE ||
          target->GetType() == cmStateEnums::STATIC_LIBRARY ||
          target->GetType() == cmStateEnums::SHARED_LIBRARY) {
        nixFileStream << "  \"" << target->GetName() << "\" = "
                      << this->GetDerivationName(target->GetName()) << ";\n";
      }
    }
  }
  
  nixFileStream << "}\n";
}

void cmGlobalNixGenerator::WritePerTranslationUnitDerivations()
{
  // TODO: Implement per-translation-unit derivation generation
  // This is Phase 1 core functionality
}

void cmGlobalNixGenerator::WriteLinkingDerivations()
{
  // TODO: Implement linking derivation generation
  // This is Phase 1 core functionality  
}

std::string cmGlobalNixGenerator::GetDerivationName(
  std::string const& targetName, std::string const& sourceFile) const
{
  if (sourceFile.empty()) {
    return "link_" + targetName;
  }
  
  // Convert source file path to valid Nix identifier
  std::string name = sourceFile;
  std::replace(name.begin(), name.end(), '/', '_');
  std::replace(name.begin(), name.end(), '.', '_');
  return targetName + "_" + name + "_o";
}

std::vector<std::string> cmGlobalNixGenerator::GetSourceDependencies(
  std::string const& /*sourceFile*/) const
{
  // TODO: Implement header dependency tracking
  // This will use CMake's existing dependency analysis
  return {};
} 