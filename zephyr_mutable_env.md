# Zephyr RTOS and Mutable Environment Requirements

## Overview

Zephyr RTOS is fundamentally incompatible with the Nix generator's pure build model. This document explains why Zephyr requires a mutable environment and what specific aspects make it incompatible with Nix's hermetic build approach.

## Why Zephyr Requires a Mutable Environment

### 1. Dynamic File Generation During Build

Zephyr's build system generates files **during the build phase** that are then immediately consumed by subsequent build steps. This violates Nix's principle that all inputs must be known before the build starts.

**Examples from test output**:
- `zephyr_version.h` - Generated by running CMake scripts that query Git
- `syscall_list.h` - Generated by parsing source files during build
- `offsets.h` - Generated by compiling and running a C program during build
- `kobj_types_enum.h` - Generated dynamically based on kernel configuration

### 2. Git Integration Requirements

The error in the test output shows:
```
CMake Error at cmake/gen_version_h.cmake:8 (include):
  include could not find requested file:
    git
```

Zephyr's build system:
- Queries Git for version information during build
- Expects to find `.git` directories
- Runs Git commands to determine build metadata
- Generates version headers based on Git state

This is incompatible with Nix because:
- Nix strips `.git` directories from sources for reproducibility
- Git commands cannot run in the sandboxed build environment
- Version information should be determined at configuration time, not build time

### 3. Multi-Stage Code Generation

Zephyr uses a complex multi-stage build process:

1. **Stage 1**: Compile special "offset" programs
2. **Stage 2**: Run these programs to generate header files
3. **Stage 3**: Use generated headers to compile the actual source
4. **Stage 4**: Parse compiled objects to generate more headers
5. **Stage 5**: Final compilation with all generated headers

This requires:
- Executing compiled binaries during the build
- Writing files to the source tree during build
- Reading previously generated files in later stages

### 4. Host Tool Execution

Zephyr expects to run host tools during build:
- Python scripts for code generation
- Custom C programs for offset calculation
- Shell scripts for file manipulation
- CMake in script mode for various tasks

The test shows custom commands like:
```
custom_samples_posix_philosophers_build_zephyr_include_generated_zephyr_version_h_5968
```

These are incompatible with Nix's sandboxed environment where:
- Only declared dependencies are available
- Network access is disabled
- File system access is restricted

### 5. Build Directory Assumptions

Zephyr assumes it can:
- Modify files in the build directory during compilation
- Create new files based on build progress
- Read configuration from mutable build artifacts

The warnings show:
```
CMake Warning:
  Source file path is outside project directory:
  /home/mpedersen/topics/cmake_nix_backend/CMake/test_zephyr_rtos/zephyr/kernel/main_weak.c
```

This indicates Zephyr's complex source tree structure where:
- Sources are scattered across multiple directories
- Build system expects specific directory layouts
- Generated files are placed in predetermined locations

## Specific Incompatibilities with Nix

### 1. Derivation Model Mismatch

Nix's derivation model requires:
- All inputs specified upfront
- No side effects during build
- Deterministic outputs based on inputs

Zephyr violates all three:
- Generates inputs during build
- Modifies build directory state
- Output depends on build-time tool execution

### 2. Sandboxing Conflicts

Nix's sandbox prevents:
- Network access (Zephyr may download files)
- Arbitrary file system access (Zephyr writes to various locations)
- Environment variable mutations (Zephyr sets/modifies env vars)

### 3. Tool Availability

Zephyr expects a full development environment:
- Git must be available and functional
- Python with specific packages
- Various code generation tools
- Shell scripting capabilities

## Potential Solutions (Theoretical)

### 1. Pre-generation Phase

One could theoretically:
- Run Zephyr's generation phase outside Nix
- Capture all generated files
- Include them as fixed inputs to Nix build

Problems:
- Loses reproducibility
- Generated files may depend on configuration
- Updates require manual regeneration

### 2. Ephemeral Nix Shells

As mentioned in todo.md, we could:
- Generate ephemeral Nix shells at configure time
- Run mutable operations in these shells
- Capture outputs for the actual build

Challenges:
- Complexity of implementation
- Still breaks Nix's purity model
- Performance overhead

### 3. Full Zephyr Packaging

The ideal solution would be:
- Package Zephyr's build tools in Nix
- Modify Zephyr to generate files at configure time
- Create proper Nix derivations for each stage

This requires:
- Significant changes to Zephyr's build system
- Cooperation from Zephyr project
- Extensive testing and validation

## Conclusion

Zephyr RTOS's build system fundamentally assumes a mutable environment where:
1. Files can be generated during build
2. Build tools can execute arbitrary commands
3. The build directory is writable throughout the process
4. Git and other development tools are available

These requirements are antithetical to Nix's design principles of:
1. Pure, deterministic builds
2. Hermetic build environments
3. Declarative specification of all inputs
4. Reproducible outputs

**Recommendation**: Users requiring Zephyr RTOS should use CMake's traditional generators (Unix Makefiles, Ninja) rather than the Nix generator. The incompatibility is fundamental and cannot be resolved without significant changes to either Zephyr's build system or Nix's build model.

## Test Output Evidence

The test failure demonstrates these issues:
```
CMake Error at cmake/gen_version_h.cmake:8 (include):
  include could not find requested file:
    git
```

This shows Zephyr trying to include Git functionality during the build phase, which is not available in Nix's sandboxed environment.