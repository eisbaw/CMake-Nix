# Generated by CMake Nix Generator
with import <nixpkgs> {};
with pkgs;
with lib;

let
# Helper function to create a fileset union from a list of paths
  makeFilesetUnion = rootPath: paths:
    let
      # Convert a path to a fileset, handling both files and directories
      toFileset = path:
        if builtins.pathExists path then
          if lib.pathIsDirectory path then
            lib.fileset.fromSource (lib.sources.sourceByRegex rootPath ["${path}/.*"])
          else
            lib.fileset.fromSource (lib.sources.sourceByRegex rootPath ["${path}"])
        else
          lib.fileset.fromSource (lib.sources.sourceByRegex rootPath []);
          
      # Create filesets for all paths
      filesets = map toFileset paths;
      
      # Start with an empty fileset
      emptySet = lib.fileset.fromSource (lib.sources.sourceByRegex rootPath []);
    in
      # Union all filesets together
      builtins.foldl' lib.fileset.union emptySet filesets;

# Helper functions will be moved to cmNixDerivationWriter
# Helper functions for DRY derivations

  cmakeNixCC = {
    name,
    src,
    compiler ? gcc,
    flags ? "",
    source,  # Source file path relative to src
    buildInputs ? []
  }: stdenv.mkDerivation {
    inherit name src buildInputs;
    dontFixup = true;
    buildPhase = ''
      mkdir -p "$(dirname "$out")"
      # Store source in a variable to handle paths with spaces
      sourceFile="${source}"
      # Determine how to invoke the compiler based on the compiler derivation
      # When using stdenv.cc, we use the wrapped compiler directly
      # For other compilers, we use the binary directly
      if [ "${compiler}" = "${stdenv.cc}" ] || [ "${compiler}" = "${pkgsi686Linux.stdenv.cc}" ]; then
        # stdenv.cc is a wrapped compiler - use it directly
        if [[ "$sourceFile" == *.cpp ]] || [[ "$sourceFile" == *.cxx ]] || [[ "$sourceFile" == *.cc ]] || [[ "$sourceFile" == *.C ]]; then
          compilerCmd="${compiler}/bin/g++"
        else
          compilerCmd="${compiler}/bin/gcc"
        fi
      else
        # For other compilers, determine the binary name
        if [ "${compiler}" = "${gcc}" ] || [ "${compiler}" = "${pkgsi686Linux.gcc}" ]; then
          if [[ "$sourceFile" == *.cpp ]] || [[ "$sourceFile" == *.cxx ]] || [[ "$sourceFile" == *.cc ]] || [[ "$sourceFile" == *.C ]]; then
            compilerBin="g++"
          else
            compilerBin="gcc"
          fi
        elif [ "${compiler}" = "${clang}" ] || [ "${compiler}" = "${pkgsi686Linux.clang}" ]; then
          if [[ "$sourceFile" == *.cpp ]] || [[ "$sourceFile" == *.cxx ]] || [[ "$sourceFile" == *.cc ]] || [[ "$sourceFile" == *.C ]]; then
            compilerBin="clang++"
          else
            compilerBin="clang"
          fi
        elif [ "${compiler}" = "${gfortran}" ] || [ "${compiler}" = "${pkgsi686Linux.gfortran}" ]; then
          compilerBin="gfortran"
        else
          compilerBin="${compiler.pname or "cc"}"
        fi
        compilerCmd="${compiler}/bin/$compilerBin"
      fi
      # When src is a directory, Nix unpacks it into a subdirectory
      # We need to find the actual source file
      # Check if source is an absolute path or Nix expression (e.g., derivation/file)
      if [[ "$sourceFile" == /* ]] || [[ "$sourceFile" == *"\$"* ]]; then
        # Absolute path or Nix expression - use as-is
        srcFile="$sourceFile"
      elif [[ -f "$sourceFile" ]]; then
        srcFile="$sourceFile"
      elif [[ -f "$(basename "$src")/$sourceFile" ]]; then
        srcFile="$(basename "$src")/$sourceFile"
      else
        echo "Error: Cannot find source file $sourceFile"
        exit 1
      fi
      $compilerCmd -c ${flags} "$srcFile" -o "$out"
    '';
    installPhase = "true";
  };

  # Linking helper function
  # NOTE: This uses Unix-style library naming conventions (lib*.a, lib*.so)
  # This is appropriate since Nix only runs on Unix-like systems (Linux, macOS)
  cmakeNixLD = {
    name,
    type ? "executable",  # "executable", "static", "shared", "module"
    objects,
    compiler ? gcc,
    compilerCommand ? null,  # Override compiler binary name (e.g., "g++" for C++)
    flags ? "",
    libraries ? [],
    buildInputs ? [],
    version ? null,
    soversion ? null,
    postBuildPhase ? ""
  }: stdenv.mkDerivation {
    inherit name objects buildInputs;
    dontUnpack = true;
    buildPhase =
      if type == "static" then ''
        # Unix static library: uses 'ar' to create lib*.a files
        mkdir -p "$(dirname "$out")"
        ar rcs "$out" $objects
      '' else if type == "shared" || type == "module" then ''
        mkdir -p $out
        # Determine compiler command - use stdenv.cc's wrapped compiler when available
        if [ "${compiler}" = "${stdenv.cc}" ] || [ "${compiler}" = "${pkgsi686Linux.stdenv.cc}" ]; then
          # Use compilerCommand override if provided, otherwise use the wrapped compiler
          compilerCmd="${if compilerCommand != null then compilerCommand else "${compiler}/bin/gcc"}"
        else
          # For other compilers, use the binary directly
          compilerBin="${if compilerCommand != null then
            compilerCommand
          else if compiler == gcc || compiler == pkgsi686Linux.gcc then
            "gcc"
          else if compiler == clang || compiler == pkgsi686Linux.clang then
            "clang"
          else if compiler == gfortran || compiler == pkgsi686Linux.gfortran then
            "gfortran"
          else
            compiler.pname or "cc"
          }";
          compilerCmd="${compiler}/bin/$compilerBin"
        fi
        # Unix library naming: static=lib*.a, shared=lib*.so, module=*.so
        libname="${if type == "module" then name else "lib" + name}.so"
        ${if version != null && type != "module" then ''
          libname="lib${name}.so.${version}"
        '' else ""}
        $compilerCmd -shared $objects ${flags} ${lib.concatMapStringsSep " " (l: l) libraries} -o "$out/$libname"
        # Create version symlinks if needed (only for shared libraries, not modules)
        ${if version != null && type != "module" then ''
          ln -sf "$libname" "$out/lib${name}.so"
          ${if soversion != null then ''
            ln -sf "$libname" "$out/lib${name}.so.${soversion}"
          '' else ""}
        '' else ""}
      '' else ''
        mkdir -p "$(dirname "$out")"
        # Determine compiler command - use stdenv.cc's wrapped compiler when available
        if [ "${compiler}" = "${stdenv.cc}" ] || [ "${compiler}" = "${pkgsi686Linux.stdenv.cc}" ]; then
          # Use compilerCommand override if provided, otherwise use the wrapped compiler
          compilerCmd="${if compilerCommand != null then compilerCommand else "${compiler}/bin/gcc"}"
        else
          # For other compilers, use the binary directly
          compilerBin="${if compilerCommand != null then
            compilerCommand
          else if compiler == gcc || compiler == pkgsi686Linux.gcc then
            "gcc"
          else if compiler == clang || compiler == pkgsi686Linux.clang then
            "clang"
          else if compiler == gfortran || compiler == pkgsi686Linux.gfortran then
            "gfortran"
          else
            compiler.pname or "cc"
          }";
          compilerCmd="${compiler}/bin/$compilerBin"
        fi
        $compilerCmd $objects ${flags} ${lib.concatMapStringsSep " " (l: l) libraries} -o "$out"
      '';
    inherit postBuildPhase;
    installPhase = "true";
  };

# Per-translation-unit derivations
  external_test_test_external_tools_main_cpp_o = cmakeNixCC {
    name = "main.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        ./../main.cpp
        ./../build/simple_external-prefix/src/simple_external/single_include
      ];
    };
    buildInputs = [ stdenv.cc (import ./../pkg_fmt.nix { inherit pkgs; }) ];
    source = "main.cpp";
    compiler = stdenv.cc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -Ibuild/simple_external-prefix/src/simple_external/single_include -std=c++17";
  };

  custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_patchdisconnected_2302 = stdenv.mkDerivation {
    name = "custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_patchdisconnected_2302";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_updatedisconnected_1843 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cat > simple_external-prefix/src/simple_external-stamp/simple_external-patch-info.txt <<'EOF_635058'
# This is a generated file and its contents are an internal implementation detail.
# The update step will be re-executed if anything in this file changes.
# No other meaning or use of this file is supported.

command=
work_dir=
EOF_635058
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_updatedisconnected_1843}/simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected
      ${pkgs.cmake}/bin/cmake -E touch simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected
      mkdir -p $out/simple_external-prefix/src/simple_external-stamp
      if [ -f simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected ]; then
        cp simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected $out/simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected
      elif [ -f simple_external-patch_disconnected ]; then
        cp simple_external-patch_disconnected $out/simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected
      fi
    '';
  };

  custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_mkdir_7664 = stdenv.mkDerivation {
    name = "custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_mkdir_7664";
    buildInputs = [ pkgs.coreutils pkgs.cmake ];
    src = /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/.;
    phases = [ "unpackPhase" "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      # Source tree was unpacked by unpackPhase
      echo "Current directory after unpack: $(pwd)"
      echo "Contents of current directory:"
      ls -la | head -10
      echo "Looking for cmake/gen_version_h.cmake:"
      ls -la cmake/gen_version_h.cmake || echo "File not found"
      ${pkgs.cmake}/bin/cmake -Dcfgdir= -P build/simple_external-prefix/tmp/simple_external-mkdirs.cmake
      ${pkgs.cmake}/bin/cmake -E touch simple_external-prefix/src/simple_external-stamp/simple_external-mkdir
      mkdir -p $out/simple_external-prefix/src/simple_external-stamp
      if [ -f simple_external-prefix/src/simple_external-stamp/simple_external-mkdir ]; then
        cp simple_external-prefix/src/simple_external-stamp/simple_external-mkdir $out/simple_external-prefix/src/simple_external-stamp/simple_external-mkdir
      elif [ -f simple_external-mkdir ]; then
        cp simple_external-mkdir $out/simple_external-prefix/src/simple_external-stamp/simple_external-mkdir
      fi
    '';
  };

  custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_install_6277 = stdenv.mkDerivation {
    name = "custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_install_6277";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_build_1533 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_build_1533}/simple_external-prefix/src/simple_external-stamp/simple_external-build simple_external-prefix/src/simple_external-stamp/simple_external-build
      ${pkgs.cmake}/bin/cmake -E touch simple_external-prefix/src/simple_external-stamp/simple_external-install
      mkdir -p $out/simple_external-prefix/src/simple_external-stamp
      if [ -f simple_external-prefix/src/simple_external-stamp/simple_external-install ]; then
        cp simple_external-prefix/src/simple_external-stamp/simple_external-install $out/simple_external-prefix/src/simple_external-stamp/simple_external-install
      elif [ -f simple_external-install ]; then
        cp simple_external-install $out/simple_external-prefix/src/simple_external-stamp/simple_external-install
      fi
    '';
  };

  custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_configure_6528 = stdenv.mkDerivation {
    name = "custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_configure_6528";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_patchdisconnected_2302 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      mkdir -p simple_external-prefix/tmp
      cat > simple_external-prefix/tmp/simple_external-cfgcmd.txt <<'EOF_66897'
cmd=''\''
EOF_66897
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_patchdisconnected_2302}/simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected
      ${pkgs.cmake}/bin/cmake -E touch simple_external-prefix/src/simple_external-stamp/simple_external-configure
      mkdir -p $out/simple_external-prefix/src/simple_external-stamp
      if [ -f simple_external-prefix/src/simple_external-stamp/simple_external-configure ]; then
        cp simple_external-prefix/src/simple_external-stamp/simple_external-configure $out/simple_external-prefix/src/simple_external-stamp/simple_external-configure
      elif [ -f simple_external-configure ]; then
        cp simple_external-configure $out/simple_external-prefix/src/simple_external-stamp/simple_external-configure
      fi
    '';
  };

  custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_build_1533 = stdenv.mkDerivation {
    name = "custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_build_1533";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_configure_6528 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_configure_6528}/simple_external-prefix/src/simple_external-stamp/simple_external-configure simple_external-prefix/src/simple_external-stamp/simple_external-configure
      ${pkgs.cmake}/bin/cmake -E touch simple_external-prefix/src/simple_external-stamp/simple_external-build
      mkdir -p $out/simple_external-prefix/src/simple_external-stamp
      if [ -f simple_external-prefix/src/simple_external-stamp/simple_external-build ]; then
        cp simple_external-prefix/src/simple_external-stamp/simple_external-build $out/simple_external-prefix/src/simple_external-stamp/simple_external-build
      elif [ -f simple_external-build ]; then
        cp simple_external-build $out/simple_external-prefix/src/simple_external-stamp/simple_external-build
      fi
    '';
  };

  custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_updatedisconnected_1843 = stdenv.mkDerivation {
    name = "custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_updatedisconnected_1843";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_download_4965 ];
    src = /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/.;
    phases = [ "unpackPhase" "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      # Source tree was unpacked by unpackPhase
      echo "Current directory after unpack: $(pwd)"
      echo "Contents of current directory:"
      ls -la | head -10
      echo "Looking for cmake/gen_version_h.cmake:"
      ls -la cmake/gen_version_h.cmake || echo "File not found"
      mkdir -p simple_external-prefix/tmp
      cat > simple_external-prefix/tmp/simple_external-gitupdate.cmake <<'EOF_870917'
# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
# file LICENSE.rst or https://cmake.org/licensing for details.

cmake_minimum_required(VERSION ${CMAKE_VERSION}) # this file comes with cmake

# Even at VERBOSE level, we don't want to see the commands executed, but
# enabling them to be shown for DEBUG may be useful to help diagnose problems.
cmake_language(GET_MESSAGE_LOG_LEVEL active_log_level)
if(active_log_level MATCHES "DEBUG|TRACE")
  set(maybe_show_command COMMAND_ECHO STDOUT)
else()
  set(maybe_show_command "")
endif()

function(do_fetch)
  message(VERBOSE "Fetching latest from the remote origin")
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git fetch --tags --force "origin"
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
    COMMAND_ERROR_IS_FATAL LAST
    ${maybe_show_command}
  )
endfunction()

function(get_hash_for_ref ref out_var err_var)
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git rev-parse "${ref}^0"
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
    RESULT_VARIABLE error_code
    OUTPUT_VARIABLE ref_hash
    ERROR_VARIABLE error_msg
    OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if(error_code)
    set(${out_var} "" PARENT_SCOPE)
  else()
    set(${out_var} "${ref_hash}" PARENT_SCOPE)
  endif()
  set(${err_var} "${error_msg}" PARENT_SCOPE)
endfunction()

get_hash_for_ref(HEAD head_sha error_msg)
if(head_sha STREQUAL "")
  message(FATAL_ERROR "Failed to get the hash for HEAD:\n${error_msg}")
endif()

if("${can_fetch}" STREQUAL "")
  set(can_fetch "NO")
endif()

execute_process(
  COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git show-ref "v3.11.2"
  WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
  OUTPUT_VARIABLE show_ref_output
)
if(show_ref_output MATCHES "^[a-z0-9]+[ \\t]+refs/remotes/")
  # Given a full remote/branch-name and we know about it already. Since
  # branches can move around, we should always fetch, if permitted.
  if(can_fetch)
    do_fetch()
  endif()
  set(checkout_name "v3.11.2")

elseif(show_ref_output MATCHES "^[a-z0-9]+[ \\t]+refs/tags/")
  # Given a tag name that we already know about. We don't know if the tag we
  # have matches the remote though (tags can move), so we should fetch. As a
  # special case to preserve backward compatibility, if we are already at the
  # same commit as the tag we hold locally, don't do a fetch and assume the tag
  # hasn't moved on the remote.
  # FIXME: We should provide an option to always fetch for this case
  get_hash_for_ref("v3.11.2" tag_sha error_msg)
  if(tag_sha STREQUAL head_sha)
    message(VERBOSE "Already at requested tag: v3.11.2")
    return()
  endif()

  if(can_fetch)
    do_fetch()
  endif()
  set(checkout_name "v3.11.2")

elseif(show_ref_output MATCHES "^[a-z0-9]+[ \\t]+refs/heads/")
  # Given a branch name without any remote and we already have a branch by that
  # name. We might already have that branch checked out or it might be a
  # different branch. It isn't fully safe to use a bare branch name without the
  # remote, so do a fetch (if allowed) and replace the ref with one that
  # includes the remote.
  if(can_fetch)
    do_fetch()
  endif()
  set(checkout_name "origin/v3.11.2")

else()
  get_hash_for_ref("v3.11.2" tag_sha error_msg)
  if(tag_sha STREQUAL head_sha)
    # Have the right commit checked out already
    message(VERBOSE "Already at requested ref: ${tag_sha}")
    return()

  elseif(tag_sha STREQUAL "")
    # We don't know about this ref yet, so we have no choice but to fetch.
    if(NOT can_fetch)
      message(FATAL_ERROR
        "Requested git ref \"v3.11.2\" is not present locally, and not "
        "allowed to contact remote due to UPDATE_DISCONNECTED setting."
      )
    endif()

    # We deliberately swallow any error message at the default log level
    # because it can be confusing for users to see a failed git command.
    # That failure is being handled here, so it isn't an error.
    if(NOT error_msg STREQUAL "")
      message(DEBUG "${error_msg}")
    endif()
    do_fetch()
    set(checkout_name "v3.11.2")

  else()
    # We have the commit, so we know we were asked to find a commit hash
    # (otherwise it would have been handled further above), but we don't
    # have that commit checked out yet. We don't need to fetch from the remote.
    set(checkout_name "v3.11.2")
    if(NOT error_msg STREQUAL "")
      message(WARNING "${error_msg}")
    endif()

  endif()
endif()

set(git_update_strategy "REBASE")
if(git_update_strategy STREQUAL "")
  # Backward compatibility requires REBASE as the default behavior
  set(git_update_strategy REBASE)
endif()

if(git_update_strategy MATCHES "^REBASE(_CHECKOUT)?$")
  # Asked to potentially try to rebase first, maybe with fallback to checkout.
  # We can't if we aren't already on a branch and we shouldn't if that local
  # branch isn't tracking the one we want to checkout.
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git symbolic-ref -q HEAD
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
    OUTPUT_VARIABLE current_branch
    OUTPUT_STRIP_TRAILING_WHITESPACE
    # Don't test for an error. If this isn't a branch, we get a non-zero error
    # code but empty output.
  )

  if(current_branch STREQUAL "")
    # Not on a branch, checkout is the only sensible option since any rebase
    # would always fail (and backward compatibility requires us to checkout in
    # this situation)
    set(git_update_strategy CHECKOUT)

  else()
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git for-each-ref "--format=%(upstream:short)" "${current_branch}"
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
      OUTPUT_VARIABLE upstream_branch
      OUTPUT_STRIP_TRAILING_WHITESPACE
      COMMAND_ERROR_IS_FATAL ANY  # There is no error if no upstream is set
    )
    if(NOT upstream_branch STREQUAL checkout_name)
      # Not safe to rebase when asked to checkout a different branch to the one
      # we are tracking. If we did rebase, we could end up with arbitrary
      # commits added to the ref we were asked to checkout if the current local
      # branch happens to be able to rebase onto the target branch. There would
      # be no error message and the user wouldn't know this was occurring.
      set(git_update_strategy CHECKOUT)
    endif()

  endif()
elseif(NOT git_update_strategy STREQUAL "CHECKOUT")
  message(FATAL_ERROR "Unsupported git update strategy: ${git_update_strategy}")
endif()


# Check if stash is needed
execute_process(
  COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git status --porcelain
  WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
  RESULT_VARIABLE error_code
  OUTPUT_VARIABLE repo_status
)
if(error_code)
  message(FATAL_ERROR "Failed to get the status")
endif()
string(LENGTH "${repo_status}" need_stash)

# If not in clean state, stash changes in order to be able to perform a
# rebase or checkout without losing those changes permanently
if(need_stash)
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash save --quiet;--include-untracked
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
    COMMAND_ERROR_IS_FATAL ANY
    ${maybe_show_command}
  )
endif()

if(git_update_strategy STREQUAL "CHECKOUT")
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git checkout "${checkout_name}"
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
    COMMAND_ERROR_IS_FATAL ANY
    ${maybe_show_command}
  )
else()
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git rebase "${checkout_name}"
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
    RESULT_VARIABLE error_code
    OUTPUT_VARIABLE rebase_output
    ERROR_VARIABLE  rebase_output
  )
  if(error_code)
    # Rebase failed, undo the rebase attempt before continuing
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git rebase --abort
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
      ${maybe_show_command}
    )

    if(NOT git_update_strategy STREQUAL "REBASE_CHECKOUT")
      # Not allowed to do a checkout as a fallback, so cannot proceed
      if(need_stash)
        execute_process(
          COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash pop --index --quiet
          WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
          ${maybe_show_command}
          )
      endif()
      message(FATAL_ERROR "\nFailed to rebase in: '/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external'."
                          "\nOutput from the attempted rebase follows:"
                          "\n${rebase_output}"
                          "\n\nYou will have to resolve the conflicts manually")
    endif()

    # Fall back to checkout. We create an annotated tag so that the user
    # can manually inspect the situation and revert if required.
    # We can't log the failed rebase output because MSVC sees it and
    # intervenes, causing the build to fail even though it completes.
    # Write it to a file instead.
    string(TIMESTAMP tag_timestamp "%Y%m%dT%H%M%S" UTC)
    set(tag_name _cmake_ExternalProject_moved_from_here_${tag_timestamp}Z)
    set(error_log_file ${CMAKE_CURRENT_LIST_DIR}/rebase_error_${tag_timestamp}Z.log)
    file(WRITE ${error_log_file} "${rebase_output}")
    message(WARNING "Rebase failed, output has been saved to ${error_log_file}"
                    "\nFalling back to checkout, previous commit tagged as ${tag_name}")
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git tag -a
              -m "ExternalProject attempting to move from here to ${checkout_name}"
              ${tag_name}
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
      COMMAND_ERROR_IS_FATAL ANY
      ${maybe_show_command}
    )

    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git checkout "${checkout_name}"
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
      COMMAND_ERROR_IS_FATAL ANY
      ${maybe_show_command}
    )
  endif()
endif()

if(need_stash)
  # Put back the stashed changes
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash pop --index --quiet
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
    RESULT_VARIABLE error_code
    ${maybe_show_command}
    )
  if(error_code)
    # Stash pop --index failed: Try again dropping the index
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git reset --hard --quiet
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
      ${maybe_show_command}
    )
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash pop --quiet
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
      RESULT_VARIABLE error_code
      ${maybe_show_command}
    )
    if(error_code)
      # Stash pop failed: Restore previous state.
      execute_process(
        COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git reset --hard --quiet ${head_sha}
        WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
        ${maybe_show_command}
      )
      execute_process(
        COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash pop --index --quiet
        WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
        ${maybe_show_command}
      )
      message(FATAL_ERROR "\nFailed to unstash changes in: '/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external'."
                          "\nYou will have to resolve the conflicts manually")
    endif()
  endif()
endif()

set(init_submodules "TRUE")
if(init_submodules)
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git"
            --git-dir=.git 
            submodule update --recursive --init 
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external"
    COMMAND_ERROR_IS_FATAL ANY
    ${maybe_show_command}
  )
endif()
EOF_870917
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cat > simple_external-prefix/src/simple_external-stamp/simple_external-update-info.txt <<'EOF_678472'
# This is a generated file and its contents are an internal implementation detail.
# The patch step will be re-executed if anything in this file changes.
# No other meaning or use of this file is supported.

command (connected)=/home/mpedersen/topics/cmake_nix_backend/CMake/bin/cmake;-Dcan_fetch=YES;-DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE;-P;/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/tmp/simple_external-gitupdate.cmake
command (disconnected)=/home/mpedersen/topics/cmake_nix_backend/CMake/bin/cmake;-Dcan_fetch=NO;-DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE;-P;/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/tmp/simple_external-gitupdate.cmake
work_dir=/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external
EOF_678472
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_download_4965}/simple_external-prefix/src/simple_external-stamp/simple_external-download simple_external-prefix/src/simple_external-stamp/simple_external-download
      ${pkgs.cmake}/bin/cmake -Dcan_fetch=NO -DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE -P build/simple_external-prefix/tmp/simple_external-gitupdate.cmake
      ${pkgs.cmake}/bin/cmake -E touch simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected
      mkdir -p $out/simple_external-prefix/src/simple_external-stamp
      if [ -f simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected ]; then
        cp simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected $out/simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected
      elif [ -f simple_external-update_disconnected ]; then
        cp simple_external-update_disconnected $out/simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected
      fi
    '';
  };

  custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_download_4965 = stdenv.mkDerivation {
    name = "custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_download_4965";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_mkdir_7664 ];
    src = /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/.;
    phases = [ "unpackPhase" "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      # Source tree was unpacked by unpackPhase
      echo "Current directory after unpack: $(pwd)"
      echo "Contents of current directory:"
      ls -la | head -10
      echo "Looking for cmake/gen_version_h.cmake:"
      ls -la cmake/gen_version_h.cmake || echo "File not found"
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cat > simple_external-prefix/src/simple_external-stamp/simple_external-gitinfo.txt <<'EOF_897221'
# This is a generated file and its contents are an internal implementation detail.
# The download step will be re-executed if anything in this file changes.
# No other meaning or use of this file is supported.

method=git
command=/home/mpedersen/topics/cmake_nix_backend/CMake/bin/cmake;-DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE;-P;/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/tmp/simple_external-gitclone.cmake
source_dir=/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external
work_dir=/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src
repository=https://github.com/nlohmann/json.git
remote=origin
init_submodules=TRUE
recurse_submodules=--recursive
submodules=
CMP0097=NEW
      
EOF_897221
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_mkdir_7664}/simple_external-prefix/src/simple_external-stamp/simple_external-mkdir simple_external-prefix/src/simple_external-stamp/simple_external-mkdir
      ${pkgs.cmake}/bin/cmake -DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE -P build/simple_external-prefix/tmp/simple_external-gitclone.cmake
      ${pkgs.cmake}/bin/cmake -E touch simple_external-prefix/src/simple_external-stamp/simple_external-download
      mkdir -p $out/simple_external-prefix/src/simple_external-stamp
      if [ -f simple_external-prefix/src/simple_external-stamp/simple_external-download ]; then
        cp simple_external-prefix/src/simple_external-stamp/simple_external-download $out/simple_external-prefix/src/simple_external-stamp/simple_external-download
      elif [ -f simple_external-download ]; then
        cp simple_external-download $out/simple_external-prefix/src/simple_external-stamp/simple_external-download
      fi
    '';
  };

  custom_build_CMakeFiles_simpleexternal_complete_9877 = stdenv.mkDerivation {
    name = "custom_build_CMakeFiles_simpleexternal_complete_9877";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_build_1533 custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_configure_6528 custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_download_4965 custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_install_6277 custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_mkdir_7664 custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_patchdisconnected_2302 custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_updatedisconnected_1843 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_install_6277}/simple_external-prefix/src/simple_external-stamp/simple_external-install simple_external-prefix/src/simple_external-stamp/simple_external-install
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_mkdir_7664}/simple_external-prefix/src/simple_external-stamp/simple_external-mkdir simple_external-prefix/src/simple_external-stamp/simple_external-mkdir
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_download_4965}/simple_external-prefix/src/simple_external-stamp/simple_external-download simple_external-prefix/src/simple_external-stamp/simple_external-download
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_updatedisconnected_1843}/simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected simple_external-prefix/src/simple_external-stamp/simple_external-update_disconnected
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_patchdisconnected_2302}/simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected simple_external-prefix/src/simple_external-stamp/simple_external-patch_disconnected
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_configure_6528}/simple_external-prefix/src/simple_external-stamp/simple_external-configure simple_external-prefix/src/simple_external-stamp/simple_external-configure
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_build_1533}/simple_external-prefix/src/simple_external-stamp/simple_external-build simple_external-prefix/src/simple_external-stamp/simple_external-build
      mkdir -p simple_external-prefix/src/simple_external-stamp
      cp ${custom_build_simpleexternal_prefix_src_simpleexternal_stamp_simpleexternal_install_6277}/simple_external-prefix/src/simple_external-stamp/simple_external-install simple_external-prefix/src/simple_external-stamp/simple_external-install
      ${pkgs.cmake}/bin/cmake -E make_directory /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/CMakeFiles
      ${pkgs.cmake}/bin/cmake -E touch CMakeFiles/simple_external-complete
      ${pkgs.cmake}/bin/cmake -E touch /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/simple_external-prefix/src/simple_external-stamp/simple_external-done
      mkdir -p $out/CMakeFiles
      if [ -f CMakeFiles/simple_external-complete ]; then
        cp CMakeFiles/simple_external-complete $out/CMakeFiles/simple_external-complete
      elif [ -f simple_external-complete ]; then
        cp simple_external-complete $out/CMakeFiles/simple_external-complete
      fi
    '';
  };

  custom_build_CMakeFiles_simpleexternal = stdenv.mkDerivation {
    name = "custom_build_CMakeFiles_simpleexternal";
    buildInputs = [ custom_build_CMakeFiles_simpleexternal_complete_9877 ];
    phases = [ "installPhase" ];
    installPhase = ''
      mkdir -p $out
      mkdir -p $out/CMakeFiles
      touch $out/CMakeFiles/simple_external
    '';
  };


  # Linking derivations
  link_external_test = cmakeNixLD {
    name = "external_test";
    type = "executable";
    buildInputs = [ gcc (import ../pkg_fmt.nix { inherit pkgs; }) ];
    objects = [ external_test_test_external_tools_main_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "-lfmt::fmt-header-only";
  };

in
{
  "external_test" = link_external_test;
}
