# Generated by CMake Nix Generator
with import <nixpkgs> {};
with pkgs;
with lib;

let
# Helper functions for DRY derivations

  cmakeNixCC = {
    name,
    src,
    compiler ? gcc,
    flags ? "",
    source,  # Source file path relative to src
    buildInputs ? [],
    propagatedInputs ? []
  }: stdenv.mkDerivation {
    inherit name src buildInputs propagatedInputs;
    dontFixup = true;
    buildPhase = ''
      mkdir -p "$(dirname "$out")"
      # Determine compiler binary name based on the compiler derivation
      compilerBin="${
        if compiler == gcc || compiler == pkgsi686Linux.gcc then
          "gcc"
        else if compiler == clang || compiler == pkgsi686Linux.clang then
          "clang"
        else if compiler == gfortran || compiler == pkgsi686Linux.gfortran then
          "gfortran"
        else
          compiler.pname or "cc"
      }"
      # When src is a directory, Nix unpacks it into a subdirectory
      # We need to find the actual source file
      # Store source in a variable to handle paths with spaces
      sourceFile="${source}"
      # Check if source is an absolute path or Nix expression (e.g., derivation/file)
      if [[ "$sourceFile" == /* ]] || [[ "$sourceFile" == *"\$"* ]]; then
        # Absolute path or Nix expression - use as-is
        srcFile="$sourceFile"
      elif [[ -f "$sourceFile" ]]; then
        srcFile="$sourceFile"
      elif [[ -f "$(basename "$src")/$sourceFile" ]]; then
        srcFile="$(basename "$src")/$sourceFile"
      else
        echo "Error: Cannot find source file $sourceFile"
        exit 1
      fi
      ${compiler}/bin/$compilerBin -c ${flags} "$srcFile" -o "$out"
    '';
    installPhase = "true";
  };

  # Linking helper function
  # NOTE: This uses Unix-style library naming conventions (lib*.a, lib*.so)
  # This is appropriate since Nix only runs on Unix-like systems (Linux, macOS)
  cmakeNixLD = {
    name,
    type ? "executable",  # "executable", "static", "shared", "module"
    objects,
    compiler ? gcc,
    compilerCommand ? null,  # Override compiler binary name (e.g., "g++" for C++)
    flags ? "",
    libraries ? [],
    buildInputs ? [],
    version ? null,
    soversion ? null,
    postBuildPhase ? ""
  }: stdenv.mkDerivation {
    inherit name objects buildInputs;
    dontUnpack = true;
    buildPhase =
      if type == "static" then ''
        # Unix static library: uses 'ar' to create lib*.a files
        mkdir -p "$(dirname "$out")"
        ar rcs "$out" $objects
      '' else if type == "shared" || type == "module" then ''
        mkdir -p $out
        compilerBin="${if compilerCommand != null then
          compilerCommand
        else if compiler == gcc || compiler == pkgsi686Linux.gcc then
          "gcc"
        else if compiler == clang || compiler == pkgsi686Linux.clang then
          "clang"
        else if compiler == gfortran || compiler == pkgsi686Linux.gfortran then
          "gfortran"
        else
          compiler.pname or "cc"
        }";
        # Unix library naming: static=lib*.a, shared=lib*.so, module=*.so
        libname="${if type == "module" then name else "lib" + name}.so"
        ${if version != null && type != "module" then ''
          libname="lib${name}.so.${version}"
        '' else ""}
        ${compiler}/bin/$compilerBin -shared $objects ${flags} ${lib.concatMapStringsSep " " (l: l) libraries} -o "$out/$libname"
        # Create version symlinks if needed (only for shared libraries, not modules)
        ${if version != null && type != "module" then ''
          ln -sf "$libname" "$out/lib${name}.so"
          ${if soversion != null then ''
            ln -sf "$libname" "$out/lib${name}.so.${soversion}"
          '' else ""}
        '' else ""}
      '' else ''
        mkdir -p "$(dirname "$out")"
        compilerBin="${if compilerCommand != null then
          compilerCommand
        else if compiler == gcc || compiler == pkgsi686Linux.gcc then
          "gcc"
        else if compiler == clang || compiler == pkgsi686Linux.clang then
          "clang"
        else if compiler == gfortran || compiler == pkgsi686Linux.gfortran then
          "gfortran"
        else
          compiler.pname or "cc"
        }";
        ${compiler}/bin/$compilerBin $objects ${flags} ${lib.concatMapStringsSep " " (l: l) libraries} -o "$out"
      '';
    inherit postBuildPhase;
    installPhase = "true";
  };

# Per-translation-unit derivations
  custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_mkdir_3592 = stdenv.mkDerivation {
    name = "custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_mkdir_3592";
    buildInputs = [ pkgs.coreutils pkgs.cmake ];
    src = /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-subbuild;
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      # Make source tree available
      export UNPACKED_SOURCE_DIR=""
      for dir in /build/*; do
        if [ -d "$dir" ] && [ -f "$dir/CMakeLists.txt" ]; then
          export UNPACKED_SOURCE_DIR="$dir"
          # Link or copy the entire source tree structure
          for item in "$dir"/*; do
            if [ -e "$item" ]; then
              ln -s "$item" . 2>/dev/null || cp -r "$item" .
            fi
          done
          # Also cd to the unpacked directory if it exists
          cd "$dir"
          break
        fi
      done
      ${pkgs.cmake}/bin/cmake -Dcfgdir= -P fmt-populate-prefix/tmp/fmt-populate-mkdirs.cmake
      ${pkgs.cmake}/bin/cmake -E touch fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-mkdir
      mkdir -p $out/fmt-populate-prefix/src/fmt-populate-stamp
      if [ -f fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-mkdir ]; then
        cp fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-mkdir $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-mkdir
      elif [ -f fmt-populate-mkdir ]; then
        cp fmt-populate-mkdir $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-mkdir
      fi
    '';
  };

  custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_download_5882 = stdenv.mkDerivation {
    name = "custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_download_5882";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_mkdir_3592 ];
    src = /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-subbuild;
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      # Make source tree available
      export UNPACKED_SOURCE_DIR=""
      for dir in /build/*; do
        if [ -d "$dir" ] && [ -f "$dir/CMakeLists.txt" ]; then
          export UNPACKED_SOURCE_DIR="$dir"
          # Link or copy the entire source tree structure
          for item in "$dir"/*; do
            if [ -e "$item" ]; then
              ln -s "$item" . 2>/dev/null || cp -r "$item" .
            fi
          done
          # Also cd to the unpacked directory if it exists
          cd "$dir"
          break
        fi
      done
      mkdir -p fmt-populate-prefix/src/fmt-populate-stamp
      cat > fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-gitinfo.txt <<'EOF'
# This is a generated file and its contents are an internal implementation detail.
# The download step will be re-executed if anything in this file changes.
# No other meaning or use of this file is supported.

method=git
command=/home/mpedersen/topics/cmake_nix_backend/CMake/bin/cmake;-DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE;-P;/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-subbuild/fmt-populate-prefix/tmp/fmt-populate-gitclone.cmake
source_dir=/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src
work_dir=/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps
repository=https://github.com/fmtlib/fmt.git
remote=origin
init_submodules=TRUE
recurse_submodules=--recursive
submodules=
CMP0097=NEW
      

EOF
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_mkdir_3592}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-mkdir .
      ${pkgs.cmake}/bin/cmake -DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE -P fmt-populate-prefix/tmp/fmt-populate-gitclone.cmake
      ${pkgs.cmake}/bin/cmake -E touch fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-download
      mkdir -p $out/fmt-populate-prefix/src/fmt-populate-stamp
      if [ -f fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-download ]; then
        cp fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-download $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-download
      elif [ -f fmt-populate-download ]; then
        cp fmt-populate-download $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-download
      fi
    '';
  };

  custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_update_7392 = stdenv.mkDerivation {
    name = "custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_update_7392";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_download_5882 ];
    src = /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-subbuild;
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      # Make source tree available
      export UNPACKED_SOURCE_DIR=""
      for dir in /build/*; do
        if [ -d "$dir" ] && [ -f "$dir/CMakeLists.txt" ]; then
          export UNPACKED_SOURCE_DIR="$dir"
          # Link or copy the entire source tree structure
          for item in "$dir"/*; do
            if [ -e "$item" ]; then
              ln -s "$item" . 2>/dev/null || cp -r "$item" .
            fi
          done
          # Also cd to the unpacked directory if it exists
          cd "$dir"
          break
        fi
      done
      mkdir -p fmt-populate-prefix/tmp
      cat > fmt-populate-prefix/tmp/fmt-populate-gitupdate.cmake <<'EOF'
# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
# file LICENSE.rst or https://cmake.org/licensing for details.

cmake_minimum_required(VERSION ${CMAKE_VERSION}) # this file comes with cmake

# Even at VERBOSE level, we don't want to see the commands executed, but
# enabling them to be shown for DEBUG may be useful to help diagnose problems.
cmake_language(GET_MESSAGE_LOG_LEVEL active_log_level)
if(active_log_level MATCHES "DEBUG|TRACE")
  set(maybe_show_command COMMAND_ECHO STDOUT)
else()
  set(maybe_show_command "")
endif()

function(do_fetch)
  message(VERBOSE "Fetching latest from the remote origin")
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git fetch --tags --force "origin"
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
    COMMAND_ERROR_IS_FATAL LAST
    ${maybe_show_command}
  )
endfunction()

function(get_hash_for_ref ref out_var err_var)
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git rev-parse "${ref}^0"
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
    RESULT_VARIABLE error_code
    OUTPUT_VARIABLE ref_hash
    ERROR_VARIABLE error_msg
    OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if(error_code)
    set(${out_var} "" PARENT_SCOPE)
  else()
    set(${out_var} "${ref_hash}" PARENT_SCOPE)
  endif()
  set(${err_var} "${error_msg}" PARENT_SCOPE)
endfunction()

get_hash_for_ref(HEAD head_sha error_msg)
if(head_sha STREQUAL "")
  message(FATAL_ERROR "Failed to get the hash for HEAD:\n${error_msg}")
endif()

if("${can_fetch}" STREQUAL "")
  set(can_fetch "YES")
endif()

execute_process(
  COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git show-ref "10.1.1"
  WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
  OUTPUT_VARIABLE show_ref_output
)
if(show_ref_output MATCHES "^[a-z0-9]+[ \\t]+refs/remotes/")
  # Given a full remote/branch-name and we know about it already. Since
  # branches can move around, we should always fetch, if permitted.
  if(can_fetch)
    do_fetch()
  endif()
  set(checkout_name "10.1.1")

elseif(show_ref_output MATCHES "^[a-z0-9]+[ \\t]+refs/tags/")
  # Given a tag name that we already know about. We don't know if the tag we
  # have matches the remote though (tags can move), so we should fetch. As a
  # special case to preserve backward compatibility, if we are already at the
  # same commit as the tag we hold locally, don't do a fetch and assume the tag
  # hasn't moved on the remote.
  # FIXME: We should provide an option to always fetch for this case
  get_hash_for_ref("10.1.1" tag_sha error_msg)
  if(tag_sha STREQUAL head_sha)
    message(VERBOSE "Already at requested tag: 10.1.1")
    return()
  endif()

  if(can_fetch)
    do_fetch()
  endif()
  set(checkout_name "10.1.1")

elseif(show_ref_output MATCHES "^[a-z0-9]+[ \\t]+refs/heads/")
  # Given a branch name without any remote and we already have a branch by that
  # name. We might already have that branch checked out or it might be a
  # different branch. It isn't fully safe to use a bare branch name without the
  # remote, so do a fetch (if allowed) and replace the ref with one that
  # includes the remote.
  if(can_fetch)
    do_fetch()
  endif()
  set(checkout_name "origin/10.1.1")

else()
  get_hash_for_ref("10.1.1" tag_sha error_msg)
  if(tag_sha STREQUAL head_sha)
    # Have the right commit checked out already
    message(VERBOSE "Already at requested ref: ${tag_sha}")
    return()

  elseif(tag_sha STREQUAL "")
    # We don't know about this ref yet, so we have no choice but to fetch.
    if(NOT can_fetch)
      message(FATAL_ERROR
        "Requested git ref \"10.1.1\" is not present locally, and not "
        "allowed to contact remote due to UPDATE_DISCONNECTED setting."
      )
    endif()

    # We deliberately swallow any error message at the default log level
    # because it can be confusing for users to see a failed git command.
    # That failure is being handled here, so it isn't an error.
    if(NOT error_msg STREQUAL "")
      message(DEBUG "${error_msg}")
    endif()
    do_fetch()
    set(checkout_name "10.1.1")

  else()
    # We have the commit, so we know we were asked to find a commit hash
    # (otherwise it would have been handled further above), but we don't
    # have that commit checked out yet. We don't need to fetch from the remote.
    set(checkout_name "10.1.1")
    if(NOT error_msg STREQUAL "")
      message(WARNING "${error_msg}")
    endif()

  endif()
endif()

set(git_update_strategy "REBASE")
if(git_update_strategy STREQUAL "")
  # Backward compatibility requires REBASE as the default behavior
  set(git_update_strategy REBASE)
endif()

if(git_update_strategy MATCHES "^REBASE(_CHECKOUT)?$")
  # Asked to potentially try to rebase first, maybe with fallback to checkout.
  # We can't if we aren't already on a branch and we shouldn't if that local
  # branch isn't tracking the one we want to checkout.
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git symbolic-ref -q HEAD
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
    OUTPUT_VARIABLE current_branch
    OUTPUT_STRIP_TRAILING_WHITESPACE
    # Don't test for an error. If this isn't a branch, we get a non-zero error
    # code but empty output.
  )

  if(current_branch STREQUAL "")
    # Not on a branch, checkout is the only sensible option since any rebase
    # would always fail (and backward compatibility requires us to checkout in
    # this situation)
    set(git_update_strategy CHECKOUT)

  else()
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git for-each-ref "--format=%(upstream:short)" "${current_branch}"
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
      OUTPUT_VARIABLE upstream_branch
      OUTPUT_STRIP_TRAILING_WHITESPACE
      COMMAND_ERROR_IS_FATAL ANY  # There is no error if no upstream is set
    )
    if(NOT upstream_branch STREQUAL checkout_name)
      # Not safe to rebase when asked to checkout a different branch to the one
      # we are tracking. If we did rebase, we could end up with arbitrary
      # commits added to the ref we were asked to checkout if the current local
      # branch happens to be able to rebase onto the target branch. There would
      # be no error message and the user wouldn't know this was occurring.
      set(git_update_strategy CHECKOUT)
    endif()

  endif()
elseif(NOT git_update_strategy STREQUAL "CHECKOUT")
  message(FATAL_ERROR "Unsupported git update strategy: ${git_update_strategy}")
endif()


# Check if stash is needed
execute_process(
  COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git status --porcelain
  WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
  RESULT_VARIABLE error_code
  OUTPUT_VARIABLE repo_status
)
if(error_code)
  message(FATAL_ERROR "Failed to get the status")
endif()
string(LENGTH "${repo_status}" need_stash)

# If not in clean state, stash changes in order to be able to perform a
# rebase or checkout without losing those changes permanently
if(need_stash)
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash save --quiet;--include-untracked
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
    COMMAND_ERROR_IS_FATAL ANY
    ${maybe_show_command}
  )
endif()

if(git_update_strategy STREQUAL "CHECKOUT")
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git checkout "${checkout_name}"
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
    COMMAND_ERROR_IS_FATAL ANY
    ${maybe_show_command}
  )
else()
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git rebase "${checkout_name}"
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
    RESULT_VARIABLE error_code
    OUTPUT_VARIABLE rebase_output
    ERROR_VARIABLE  rebase_output
  )
  if(error_code)
    # Rebase failed, undo the rebase attempt before continuing
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git rebase --abort
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
      ${maybe_show_command}
    )

    if(NOT git_update_strategy STREQUAL "REBASE_CHECKOUT")
      # Not allowed to do a checkout as a fallback, so cannot proceed
      if(need_stash)
        execute_process(
          COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash pop --index --quiet
          WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
          ${maybe_show_command}
          )
      endif()
      message(FATAL_ERROR "\nFailed to rebase in: '/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src'."
                          "\nOutput from the attempted rebase follows:"
                          "\n${rebase_output}"
                          "\n\nYou will have to resolve the conflicts manually")
    endif()

    # Fall back to checkout. We create an annotated tag so that the user
    # can manually inspect the situation and revert if required.
    # We can't log the failed rebase output because MSVC sees it and
    # intervenes, causing the build to fail even though it completes.
    # Write it to a file instead.
    string(TIMESTAMP tag_timestamp "%Y%m%dT%H%M%S" UTC)
    set(tag_name _cmake_ExternalProject_moved_from_here_${tag_timestamp}Z)
    set(error_log_file ${CMAKE_CURRENT_LIST_DIR}/rebase_error_${tag_timestamp}Z.log)
    file(WRITE ${error_log_file} "${rebase_output}")
    message(WARNING "Rebase failed, output has been saved to ${error_log_file}"
                    "\nFalling back to checkout, previous commit tagged as ${tag_name}")
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git tag -a
              -m "ExternalProject attempting to move from here to ${checkout_name}"
              ${tag_name}
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
      COMMAND_ERROR_IS_FATAL ANY
      ${maybe_show_command}
    )

    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git checkout "${checkout_name}"
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
      COMMAND_ERROR_IS_FATAL ANY
      ${maybe_show_command}
    )
  endif()
endif()

if(need_stash)
  # Put back the stashed changes
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash pop --index --quiet
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
    RESULT_VARIABLE error_code
    ${maybe_show_command}
    )
  if(error_code)
    # Stash pop --index failed: Try again dropping the index
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git reset --hard --quiet
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
      ${maybe_show_command}
    )
    execute_process(
      COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash pop --quiet
      WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
      RESULT_VARIABLE error_code
      ${maybe_show_command}
    )
    if(error_code)
      # Stash pop failed: Restore previous state.
      execute_process(
        COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git reset --hard --quiet ${head_sha}
        WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
        ${maybe_show_command}
      )
      execute_process(
        COMMAND "/etc/profiles/per-user/mpedersen/bin/git" --git-dir=.git stash pop --index --quiet
        WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
        ${maybe_show_command}
      )
      message(FATAL_ERROR "\nFailed to unstash changes in: '/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src'."
                          "\nYou will have to resolve the conflicts manually")
    endif()
  endif()
endif()

set(init_submodules "TRUE")
if(init_submodules)
  execute_process(
    COMMAND "/etc/profiles/per-user/mpedersen/bin/git"
            --git-dir=.git 
            submodule update --recursive --init 
    WORKING_DIRECTORY "/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src"
    COMMAND_ERROR_IS_FATAL ANY
    ${maybe_show_command}
  )
endif()

EOF
      mkdir -p fmt-populate-prefix/src/fmt-populate-stamp
      cat > fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-update-info.txt <<'EOF'
# This is a generated file and its contents are an internal implementation detail.
# The patch step will be re-executed if anything in this file changes.
# No other meaning or use of this file is supported.

command (connected)=/home/mpedersen/topics/cmake_nix_backend/CMake/bin/cmake;-Dcan_fetch=YES;-DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE;-P;/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-subbuild/fmt-populate-prefix/tmp/fmt-populate-gitupdate.cmake
command (disconnected)=/home/mpedersen/topics/cmake_nix_backend/CMake/bin/cmake;-Dcan_fetch=NO;-DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE;-P;/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-subbuild/fmt-populate-prefix/tmp/fmt-populate-gitupdate.cmake
work_dir=/home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-src

EOF
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_download_5882}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-download .
      ${pkgs.cmake}/bin/cmake -Dcan_fetch=YES -DCMAKE_MESSAGE_LOG_LEVEL=VERBOSE -P fmt-populate-prefix/tmp/fmt-populate-gitupdate.cmake
      mkdir -p $out/fmt-populate-prefix/src/fmt-populate-stamp
      if [ -f fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-update ]; then
        cp fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-update $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-update
      elif [ -f fmt-populate-update ]; then
        cp fmt-populate-update $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-update
      fi
    '';
  };

  custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_patch_9560 = stdenv.mkDerivation {
    name = "custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_patch_9560";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_update_7392 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      mkdir -p fmt-populate-prefix/src/fmt-populate-stamp
      cat > fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-patch-info.txt <<'EOF'
# This is a generated file and its contents are an internal implementation detail.
# The update step will be re-executed if anything in this file changes.
# No other meaning or use of this file is supported.

command=
work_dir=

EOF
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_update_7392}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-update .
      ${pkgs.cmake}/bin/cmake -E touch fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-patch
      mkdir -p $out/fmt-populate-prefix/src/fmt-populate-stamp
      if [ -f fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-patch ]; then
        cp fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-patch $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-patch
      elif [ -f fmt-populate-patch ]; then
        cp fmt-populate-patch $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-patch
      fi
    '';
  };

  custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_configure_5805 = stdenv.mkDerivation {
    name = "custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_configure_5805";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_patch_9560 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      mkdir -p fmt-populate-prefix/tmp
      cat > fmt-populate-prefix/tmp/fmt-populate-cfgcmd.txt <<'EOF'
cmd=''

EOF
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_patch_9560}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-patch .
      ${pkgs.cmake}/bin/cmake -E touch fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-configure
      mkdir -p $out/fmt-populate-prefix/src/fmt-populate-stamp
      if [ -f fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-configure ]; then
        cp fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-configure $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-configure
      elif [ -f fmt-populate-configure ]; then
        cp fmt-populate-configure $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-configure
      fi
    '';
  };

  custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_build_2588 = stdenv.mkDerivation {
    name = "custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_build_2588";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_configure_5805 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_configure_5805}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-configure .
      ${pkgs.cmake}/bin/cmake -E touch fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-build
      mkdir -p $out/fmt-populate-prefix/src/fmt-populate-stamp
      if [ -f fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-build ]; then
        cp fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-build $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-build
      elif [ -f fmt-populate-build ]; then
        cp fmt-populate-build $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-build
      fi
    '';
  };

  custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_install_6269 = stdenv.mkDerivation {
    name = "custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_install_6269";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_build_2588 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_build_2588}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-build .
      ${pkgs.cmake}/bin/cmake -E touch fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-install
      mkdir -p $out/fmt-populate-prefix/src/fmt-populate-stamp
      if [ -f fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-install ]; then
        cp fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-install $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-install
      elif [ -f fmt-populate-install ]; then
        cp fmt-populate-install $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-install
      fi
    '';
  };

  custom_CMakeFiles_fmt_populate_complete_7965 = stdenv.mkDerivation {
    name = "custom_CMakeFiles_fmt_populate_complete_7965";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_install_6269 custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_mkdir_3592 custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_download_5882 custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_update_7392 custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_patch_9560 custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_configure_5805 custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_build_2588 custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_test_7704 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_install_6269}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-install .
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_mkdir_3592}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-mkdir .
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_download_5882}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-download .
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_update_7392}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-update .
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_patch_9560}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-patch .
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_configure_5805}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-configure .
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_build_2588}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-build .
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_install_6269}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-install .
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_test_7704}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-test .
      ${pkgs.cmake}/bin/cmake -E make_directory /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-subbuild/CMakeFiles
      ${pkgs.cmake}/bin/cmake -E touch CMakeFiles/fmt-populate-complete
      ${pkgs.cmake}/bin/cmake -E touch /home/mpedersen/topics/cmake_nix_backend/CMake/test_external_tools/build/_deps/fmt-subbuild/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-done
      mkdir -p $out/CMakeFiles
      if [ -f CMakeFiles/fmt-populate-complete ]; then
        cp CMakeFiles/fmt-populate-complete $out/CMakeFiles/fmt-populate-complete
      elif [ -f fmt-populate-complete ]; then
        cp fmt-populate-complete $out/CMakeFiles/fmt-populate-complete
      fi
    '';
  };

  custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_test_7704 = stdenv.mkDerivation {
    name = "custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_test_7704";
    buildInputs = [ pkgs.coreutils pkgs.cmake custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_install_6269 ];
    phases = [ "buildPhase" ];
    buildPhase = ''
      mkdir -p $out
      cp ${custom_fmt_populate_prefix_src_fmt_populate_stamp_fmt_populate_install_6269}/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-install .
      ${pkgs.cmake}/bin/cmake -E touch fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-test
      mkdir -p $out/fmt-populate-prefix/src/fmt-populate-stamp
      if [ -f fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-test ]; then
        cp fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-test $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-test
      elif [ -f fmt-populate-test ]; then
        cp fmt-populate-test $out/fmt-populate-prefix/src/fmt-populate-stamp/fmt-populate-test
      fi
    '';
  };

  custom_CMakeFiles_fmt_populate = stdenv.mkDerivation {
    name = "custom_CMakeFiles_fmt_populate";
    buildInputs = [ custom_CMakeFiles_fmt_populate_complete_7965 ];
    phases = [ "installPhase" ];
    installPhase = ''
      mkdir -p $out
      mkdir -p $out/CMakeFiles
      touch $out/CMakeFiles/fmt-populate
    '';
  };


  # Linking derivations
in
{
}
