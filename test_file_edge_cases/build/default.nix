# Generated by CMake Nix Generator
with import <nixpkgs> {};
with pkgs;
with lib;

let
# Helper functions for DRY derivations

  cmakeNixCC = {
    name,
    src,
    compiler ? gcc,
    flags ? "",
    source,  # Source file path relative to src
    buildInputs ? [],
    propagatedInputs ? []
  }: stdenv.mkDerivation {
    inherit name src buildInputs propagatedInputs;
    dontFixup = true;
    buildPhase = ''
      mkdir -p "$(dirname "$out")"
      # Determine compiler binary name based on the compiler derivation
      compilerBin="${
        if compiler == gcc || compiler == pkgsi686Linux.gcc then
          "gcc"
        else if compiler == clang || compiler == pkgsi686Linux.clang then
          "clang"
        else if compiler == gfortran || compiler == pkgsi686Linux.gfortran then
          "gfortran"
        else
          compiler.pname or "cc"
      }"
      # When src is a directory, Nix unpacks it into a subdirectory
      # We need to find the actual source file
      # Store source in a variable to handle paths with spaces
      sourceFile="${source}"
      # Check if source is an absolute path or Nix expression (e.g., derivation/file)
      if [[ "$sourceFile" == /* ]] || [[ "$sourceFile" == *"\$"* ]]; then
        # Absolute path or Nix expression - use as-is
        srcFile="$sourceFile"
      elif [[ -f "$sourceFile" ]]; then
        srcFile="$sourceFile"
      elif [[ -f "$(basename "$src")/$sourceFile" ]]; then
        srcFile="$(basename "$src")/$sourceFile"
      else
        echo "Error: Cannot find source file $sourceFile"
        exit 1
      fi
      ${compiler}/bin/$compilerBin -c ${flags} "$srcFile" -o "$out"
    '';
    installPhase = "true";
  };

  # Linking helper function
  # NOTE: This uses Unix-style library naming conventions (lib*.a, lib*.so)
  # This is appropriate since Nix only runs on Unix-like systems (Linux, macOS)
  cmakeNixLD = {
    name,
    type ? "executable",  # "executable", "static", "shared", "module"
    objects,
    compiler ? gcc,
    compilerCommand ? null,  # Override compiler binary name (e.g., "g++" for C++)
    flags ? "",
    libraries ? [],
    buildInputs ? [],
    version ? null,
    soversion ? null,
    postBuildPhase ? ""
  }: stdenv.mkDerivation {
    inherit name objects buildInputs;
    dontUnpack = true;
    buildPhase =
      if type == "static" then ''
        # Unix static library: uses 'ar' to create lib*.a files
        mkdir -p "$(dirname "$out")"
        ar rcs "$out" $objects
      '' else if type == "shared" || type == "module" then ''
        mkdir -p $out
        compilerBin="${if compilerCommand != null then
          compilerCommand
        else if compiler == gcc || compiler == pkgsi686Linux.gcc then
          "gcc"
        else if compiler == clang || compiler == pkgsi686Linux.clang then
          "clang"
        else if compiler == gfortran || compiler == pkgsi686Linux.gfortran then
          "gfortran"
        else
          compiler.pname or "cc"
        }";
        # Unix library naming: static=lib*.a, shared=lib*.so, module=*.so
        libname="${if type == "module" then name else "lib" + name}.so"
        ${if version != null && type != "module" then ''
          libname="lib${name}.so.${version}"
        '' else ""}
        ${compiler}/bin/$compilerBin -shared $objects ${flags} ${lib.concatMapStringsSep " " (l: l) libraries} -o "$out/$libname"
        # Create version symlinks if needed (only for shared libraries, not modules)
        ${if version != null && type != "module" then ''
          ln -sf "$libname" "$out/lib${name}.so"
          ${if soversion != null then ''
            ln -sf "$libname" "$out/lib${name}.so.${soversion}"
          '' else ""}
        '' else ""}
      '' else ''
        mkdir -p "$(dirname "$out")"
        compilerBin="${if compilerCommand != null then
          compilerCommand
        else if compiler == gcc || compiler == pkgsi686Linux.gcc then
          "gcc"
        else if compiler == clang || compiler == pkgsi686Linux.clang then
          "clang"
        else if compiler == gfortran || compiler == pkgsi686Linux.gfortran then
          "gfortran"
        else
          compiler.pname or "cc"
        }";
        ${compiler}/bin/$compilerBin $objects ${flags} ${lib.concatMapStringsSep " " (l: l) libraries} -o "$out"
      '';
    inherit postBuildPhase;
    installPhase = "true";
  };

# Per-translation-unit derivations
  test_spaces_test_file_edge_cases_source_with_spaces_cpp_o = cmakeNixCC {
    name = "source with spaces.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        (./.. + "/source with spaces.cpp")
        (./.. + "/include with spaces")
      ];
    };
    buildInputs = [ gcc ];
    source = "source with spaces.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -I\"include with spaces\" -std=c++17";
  };

  test-with-dashes_test_file_edge_cases_special_chars_cpp_o = cmakeNixCC {
    name = "special_chars.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        ./../special_chars.cpp
      ];
    };
    buildInputs = [ gcc ];
    source = "special_chars.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -std=c++17";
  };

  test_with_underscores_test_file_edge_cases_special_chars_cpp_o = cmakeNixCC {
    name = "special_chars.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        ./../special_chars.cpp
      ];
    };
    buildInputs = [ gcc ];
    source = "special_chars.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -std=c++17";
  };

  test_with_dots_test_file_edge_cases_special_chars_cpp_o = cmakeNixCC {
    name = "special_chars.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        ./../special_chars.cpp
      ];
    };
    buildInputs = [ gcc ];
    source = "special_chars.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -std=c++17";
  };

  test_unicode_test_file_edge_cases_unicode________cpp_o = cmakeNixCC {
    name = "unicode_文件.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        (./.. + "/unicode_文件.cpp")
      ];
    };
    buildInputs = [ gcc ];
    source = "unicode_文件.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -std=c++17";
  };

  test_long_names_test_file_edge_cases_this_is_a_very_long_filename_that_might_cause_issues_with_some_build_systems_but_should_work_fine_cpp_o = cmakeNixCC {
    name = "this_is_a_very_long_filename_that_might_cause_issues_with_some_build_systems_but_should_work_fine.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        ./../this_is_a_very_long_filename_that_might_cause_issues_with_some_build_systems_but_should_work_fine.cpp
      ];
    };
    buildInputs = [ gcc ];
    source = "this_is_a_very_long_filename_that_might_cause_issues_with_some_build_systems_but_should_work_fine.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -std=c++17";
  };

  test_symlinks_test_file_edge_cases_special_chars_cpp_o = cmakeNixCC {
    name = "symlinked_source.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        ./../special_chars.cpp
      ];
    };
    buildInputs = [ gcc ];
    source = "special_chars.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -std=c++17";
  };

  TestMixedCase_test_file_edge_cases_MixedCase_cpp_o = cmakeNixCC {
    name = "MixedCase.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        ./../MixedCase.cpp
      ];
    };
    buildInputs = [ gcc ];
    source = "MixedCase.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -std=c++17";
  };

  test_nested_structure_nested_cpp_o = cmakeNixCC {
    name = "nested.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        ./../very/deeply/nested/directory/structure/nested.cpp
      ];
    };
    buildInputs = [ gcc ];
    source = "very/deeply/nested/directory/structure/nested.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -std=c++17";
  };

  test_dir_spaces_dir_with_spaces_file_cpp_o = cmakeNixCC {
    name = "file.o";
    src = fileset.toSource {
      root = ./..;
      fileset = fileset.unions [
        (./.. + "/dir with spaces/file.cpp")
        (./.. + "/include with spaces")
      ];
    };
    buildInputs = [ gcc ];
    source = "dir with spaces/file.cpp";
    compiler = gcc;
    flags = "-O3 -DNDEBUG -std=gnu++17 -I\"include with spaces\" -std=c++17";
  };


  # Linking derivations
  link_test_spaces = cmakeNixLD {
    name = "test_spaces";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test_spaces_test_file_edge_cases_source_with_spaces_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_test-with-dashes = cmakeNixLD {
    name = "test-with-dashes";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test-with-dashes_test_file_edge_cases_special_chars_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_test_with_underscores = cmakeNixLD {
    name = "test_with_underscores";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test_with_underscores_test_file_edge_cases_special_chars_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_test_with_dots = cmakeNixLD {
    name = "test.with.dots";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test_with_dots_test_file_edge_cases_special_chars_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_test_unicode = cmakeNixLD {
    name = "test_unicode";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test_unicode_test_file_edge_cases_unicode________cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_test_long_names = cmakeNixLD {
    name = "test_long_names";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test_long_names_test_file_edge_cases_this_is_a_very_long_filename_that_might_cause_issues_with_some_build_systems_but_should_work_fine_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_test_symlinks = cmakeNixLD {
    name = "test_symlinks";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test_symlinks_test_file_edge_cases_special_chars_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_TestMixedCase = cmakeNixLD {
    name = "TestMixedCase";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ TestMixedCase_test_file_edge_cases_MixedCase_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_test_nested = cmakeNixLD {
    name = "test_nested";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test_nested_structure_nested_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_test_dir_spaces = cmakeNixLD {
    name = "test_dir_spaces";
    type = "executable";
    buildInputs = [ gcc ];
    objects = [ test_dir_spaces_dir_with_spaces_file_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

in
{
  "test_spaces" = link_test_spaces;
  "test-with-dashes" = link_test-with-dashes;
  "test_with_underscores" = link_test_with_underscores;
  "test.with.dots" = link_test_with_dots;
  "test_unicode" = link_test_unicode;
  "test_long_names" = link_test_long_names;
  "test_symlinks" = link_test_symlinks;
  "TestMixedCase" = link_TestMixedCase;
  "test_nested" = link_test_nested;
  "test_dir_spaces" = link_test_dir_spaces;
}
