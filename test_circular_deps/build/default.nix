# Generated by CMake Nix Generator
with import <nixpkgs> {};
with pkgs;
with lib;

let
# Helper functions for DRY derivations

  cmakeNixCC = {
    name,
    src,
    compiler ? gcc,
    flags ? "",
    source,  # Source file path relative to src
    buildInputs ? [],
    propagatedInputs ? []
  }: stdenv.mkDerivation {
    inherit name src buildInputs propagatedInputs;
    dontFixup = true;
    buildPhase = ''
      compilerBin=$(
        if [[ "${compiler}" == "${gcc}" ]]; then
          echo "gcc"
        elif [[ "${compiler}" == "${clang}" ]]; then
          echo "clang"
        elif [[ "${compiler}" == "${gfortran}" ]]; then
          echo "gfortran"
        else
          echo "${compiler.pname or "cc"}"
        fi
      )
      ${compiler}/bin/$compilerBin -c ${flags} "${source}" -o "$out"
    '';
    installPhase = "true";
  };

  # Linking helper function
  # NOTE: This uses Unix-style library naming conventions (lib*.a, lib*.so)
  # This is appropriate since Nix only runs on Unix-like systems (Linux, macOS)
  cmakeNixLD = {
    name,
    type ? "executable",  # "executable", "static", "shared", "module"
    objects,
    compiler ? gcc,
    compilerCommand ? null,  # Override compiler binary name (e.g., "g++" for C++)
    flags ? "",
    libraries ? [],
    buildInputs ? [],
    version ? null,
    soversion ? null,
    postBuildPhase ? ""
  }: stdenv.mkDerivation {
    inherit name objects buildInputs;
    dontUnpack = true;
    buildPhase =
      if type == "static" then ''
        # Unix static library: uses 'ar' to create lib*.a files
        ar rcs "$out" $objects
      '' else if type == "shared" || type == "module" then ''
        mkdir -p $out
        compilerBin=${if compilerCommand != null then
          compilerCommand
        else if compiler == gcc then
          "gcc"
        else if compiler == clang then
          "clang"
        else if compiler == gfortran then
          "gfortran"
        else
          compiler.pname or "cc"
        }
        # Unix library naming: static=lib*.a, shared=lib*.so, module=*.so
        libname="${if type == "module" then name else "lib" + name}.so"
        ${if version != null && type != "module" then ''
          libname="lib${name}.so.${version}"
        '' else ""}
        ${compiler}/bin/$compilerBin -shared $objects ${flags} ${lib.concatMapStringsSep " " (l: l) libraries} -o "$out/$libname"
        # Create version symlinks if needed (only for shared libraries, not modules)
        ${if version != null && type != "module" then ''
          ln -sf "$libname" "$out/lib${name}.so"
          ${if soversion != null then ''
            ln -sf "$libname" "$out/lib${name}.so.${soversion}"
          '' else ""}
        '' else ""}
      '' else ''
        compilerBin=${if compilerCommand != null then
          compilerCommand
        else if compiler == gcc then
          "gcc"
        else if compiler == clang then
          "clang"
        else if compiler == gfortran then
          "gfortran"
        else
          compiler.pname or "cc"
        }
        ${compiler}/bin/$compilerBin $objects ${flags} ${lib.concatMapStringsSep " " (l: l) libraries} -o "$out"
      '';
    inherit postBuildPhase;
    installPhase = "true";
  };

# Per-translation-unit derivations
  libA_test_circular_deps_libA_cpp_o = cmakeNixCC {
    name = "libA.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "libA.cpp";
    compiler = gcc;
    flags = "-g";
  };

  libB_test_circular_deps_libB_cpp_o = cmakeNixCC {
    name = "libB.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "libB.cpp";
    compiler = gcc;
    flags = "-g";
  };

  libX_test_circular_deps_libX_cpp_o = cmakeNixCC {
    name = "libX.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "libX.cpp";
    compiler = gcc;
    flags = "-g";
  };

  libY_test_circular_deps_libY_cpp_o = cmakeNixCC {
    name = "libY.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "libY.cpp";
    compiler = gcc;
    flags = "-g";
  };

  libZ_test_circular_deps_libZ_cpp_o = cmakeNixCC {
    name = "libZ.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "libZ.cpp";
    compiler = gcc;
    flags = "-g";
  };

  lib1_test_circular_deps_lib1_cpp_o = cmakeNixCC {
    name = "lib1.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "lib1.cpp";
    compiler = gcc;
    flags = "-g";
  };

  lib2_test_circular_deps_lib2_cpp_o = cmakeNixCC {
    name = "lib2.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "lib2.cpp";
    compiler = gcc;
    flags = "-g";
  };

  lib3_test_circular_deps_lib3_cpp_o = cmakeNixCC {
    name = "lib3.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "lib3.cpp";
    compiler = gcc;
    flags = "-g";
  };

  valid_app_test_circular_deps_main_cpp_o = cmakeNixCC {
    name = "main.o";
    src = ./..;
    buildInputs = [ gcc ];
    source = "main.cpp";
    compiler = gcc;
    flags = "-g";
  };


  # Linking derivations
  link_libA = cmakeNixLD {
    name = "libA";
    type = "static";
    buildInputs = [gcc ];
    objects = [libA_test_circular_deps_libA_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "${link_libB}";
  };

  link_libB = cmakeNixLD {
    name = "libB";
    type = "static";
    buildInputs = [gcc ];
    objects = [libB_test_circular_deps_libB_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "${link_libA}";
  };

  link_libX = cmakeNixLD {
    name = "libX";
    type = "static";
    buildInputs = [gcc ];
    objects = [libX_test_circular_deps_libX_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "${link_libY}";
  };

  link_libY = cmakeNixLD {
    name = "libY";
    type = "static";
    buildInputs = [gcc ];
    objects = [libY_test_circular_deps_libY_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "${link_libZ}";
  };

  link_libZ = cmakeNixLD {
    name = "libZ";
    type = "static";
    buildInputs = [gcc ];
    objects = [libZ_test_circular_deps_libZ_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "${link_libX}";
  };

  link_lib1 = cmakeNixLD {
    name = "lib1";
    type = "static";
    buildInputs = [gcc ];
    objects = [lib1_test_circular_deps_lib1_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "${link_lib2}";
  };

  link_lib2 = cmakeNixLD {
    name = "lib2";
    type = "static";
    buildInputs = [gcc ];
    objects = [lib2_test_circular_deps_lib2_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "${link_lib3}";
  };

  link_lib3 = cmakeNixLD {
    name = "lib3";
    type = "static";
    buildInputs = [gcc ];
    objects = [lib3_test_circular_deps_lib3_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
  };

  link_valid_app = cmakeNixLD {
    name = "valid_app";
    type = "executable";
    buildInputs = [gcc ];
    objects = [valid_app_test_circular_deps_main_cpp_o ];
    compiler = gcc;
    compilerCommand = "g++";
    flags = "${link_lib1}";
  };

in
{
  "libA" = link_libA;
  "libB" = link_libB;
  "libX" = link_libX;
  "libY" = link_libY;
  "libZ" = link_libZ;
  "lib1" = link_lib1;
  "lib2" = link_lib2;
  "lib3" = link_lib3;
  "valid_app" = link_valid_app;
}
